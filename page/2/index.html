<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chenguanghua.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="热心的蚂蚁的博客">
<meta property="og:url" content="https://chenguanghua.github.io/page/2/index.html">
<meta property="og:site_name" content="热心的蚂蚁的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="热心的蚂蚁">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chenguanghua.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>热心的蚂蚁的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">热心的蚂蚁的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/%E9%A6%96%E9%A1%B5" rel="section">首页</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">热心的蚂蚁</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2023/02/22/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/22/mysql/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-22 17:16:51" itemprop="dateCreated datePublished" datetime="2023-02-22T17:16:51+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-09 14:09:22" itemprop="dateModified" datetime="2023-02-09T14:09:22+08:00">2023-02-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-MVVC"><a href="#1-MVVC" class="headerlink" title="1. MVVC"></a>1. MVVC</h2><blockquote>
<p>MVCC用于读已提交和可重复读级别的控制，主要通过undo log日志版本链和read view来实现</p>
</blockquote>
<p>每个字段隐藏两个字段： roll_pointer<code>和</code>trx_id</p>
<p>roll_pointer指向更新事务之前生成的undo log，undo log用于事务的回滚，保证事务的原子性。</p>
<p>trx_id就是最近一次更新数据的事务ID</p>
<p><strong>ReadView 重要概念：</strong></p>
<ol>
<li>m_ids，就是还未提交的事务id集合</li>
<li>low_limit_id，ReadView 生成时刻系统尚未分配的下一个事务 ID</li>
<li>up_limit_id，<strong>是 trx_list 列表中事务 ID 最小的 ID</strong></li>
<li>creator_trx_id，创建read view的事务ID，也就是自己的事务</li>
</ol>
<p><strong>ReadView原理：</strong></p>
<ol>
<li>如果trx_id&lt;up_limit_id，那么说明就是之前事务的数据，直接返回，也就对应了小明第一次开启事务查询的场景</li>
<li>如果trx_id&gt;low_limit_id，trx_id还在[up_limit_id，low_limit_id]范围之内，并且trx_id在m_ids中，就会根据roll_pointer去查找undo log日志链，找到之前版本的数据。</li>
<li>如果trx_id&#x3D;creator_trx_id，那么说明就是自己修改的，直接返回就好了，对应的就是自己去修改数据的场景</li>
</ol>
<p><strong>不同隔离级别创建ReadView</strong> </p>
<ol>
<li>读提交</li>
</ol>
<p>​       每次查询都会生成一次read view</p>
<ol>
<li>可重复读</li>
</ol>
<p>​       整个事务生成一次快照读，并且在第一次读取时</p>
<h2 id="2-mysql-事务"><a href="#2-mysql-事务" class="headerlink" title="2. mysql 事务"></a>2. mysql 事务</h2><ul>
<li>原子性 ： 要么都成功，要么都失败</li>
<li>一致性 ： 从一个状态转换另一个稳定状态</li>
<li>隔离性 : 事务之间互补影响</li>
<li>持久性 :  事务一旦提交就永久有效</li>
</ul>
<h3 id="2-1-事务实现"><a href="#2-1-事务实现" class="headerlink" title="2.1 事务实现"></a>2.1 事务实现</h3><p><img src="/.%5Cmysql%5Cmysql%E4%BA%8B%E5%8A%A1.svg" alt="mysql事务"></p>
<p>redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p>
<h4 id="2-1-1-redo-log-重做日志"><a href="#2-1-1-redo-log-重做日志" class="headerlink" title="2.1.1 redo log 重做日志"></a>2.1.1 redo log 重做日志</h4><p>redo log 有两部分组成 redo log buffer ，redo log  file</p>
<p>redo log 写入流程：</p>
<ul>
<li><p>执行update操作。</p>
</li>
<li><p>先将原始数据从磁盘读取到内存，修改内存中的数据。</p>
</li>
<li><p>生成一条重做日志写入redo log buffer，记录数据被修改后的值。</p>
</li>
<li><p>当事务提交时，需要将redo log buffer中的内容刷新到redo log file。</p>
</li>
<li><p>事务提交后，也会将内存中修改数据的值写入磁盘。</p>
</li>
</ul>
<p><strong>redo log为什么可以实现事务的原子性和持久性？</strong></p>
<ul>
<li><p>原子性，是redo log记录了事务期间操作的物理日志，事务提交之前，并没有写入磁盘，保存在内存里，如果事务失败，数据库磁盘不会有影响，回滚掉事务内存部分即可。</p>
</li>
<li><p>持久性，redo log 会在事务提交时将日志存储到磁盘redo log file，保证日志的持久性。</p>
</li>
</ul>
<h3 id="2-1-2-事务隔离级别"><a href="#2-1-2-事务隔离级别" class="headerlink" title="2.1.2  事务隔离级别"></a>2.1.2  事务隔离级别</h3><p>READ-UNCOMMITTED: 读未提交</p>
<p>READ-COMMITTED：读以提交</p>
<p>REPEATABLE-READ：可重复读</p>
<p>SERIALIZABLE: 序列化</p>
<h2 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3. 执行流程"></a>3. 执行流程</h2><ol>
<li>客户端发送更新命令到MySQL服务器，经过处理连接、解析优化等步骤；</li>
<li>Server层向InnoDB存储引擎要id&#x3D;1的这条记录；</li>
<li>存储引擎先从缓存中查找这条记录，有的话直接返回，没有则从磁盘加载到缓存中然后返回；</li>
<li>Server层执行器修改这条记录的name字段值；</li>
<li>存储引擎更新修改到内存中；</li>
<li>存储引擎记录redo日志，并将状态设置为<code>prepare</code>状态；</li>
<li>存储引擎通知执行器，修改完毕，可以进行事务提交；</li>
<li>Server先写了个binlog；</li>
<li>Server提交事务；</li>
<li>存储引擎将redo日志中和当前事务相关的记录状态设置为<code>commit</code>状态。</li>
</ol>
<h2 id="4-调优"><a href="#4-调优" class="headerlink" title="4. 调优"></a>4. 调优</h2><h3 id="4-1-工具-Explain使用"><a href="#4-1-工具-Explain使用" class="headerlink" title="4.1 工具 Explain使用"></a>4.1 工具 Explain使用</h3><p>select： all-&gt;index-&gt;rang-&gt;ref-&gt;const   查询速度递增</p>
<h3 id="4-2-mysql-优化原则"><a href="#4-2-mysql-优化原则" class="headerlink" title="4.2 mysql 优化原则"></a>4.2 mysql 优化原则</h3><ul>
<li>最左匹配</li>
<li>避免回表，（覆盖索引）</li>
<li>索引下推 5.6</li>
<li>不为离散度低数据设置索引 如sex</li>
<li>随机无序的值不作为索引，如身份证号，UUID</li>
<li>为用于搜索，排序，分组字段建立索引</li>
<li>频繁更新字段不适合作为索引</li>
</ul>
<h3 id="4-3-大表如何删除数据"><a href="#4-3-大表如何删除数据" class="headerlink" title="4.3 大表如何删除数据"></a>4.3 大表如何删除数据</h3><ul>
<li>删除索引</li>
<li>删除数据</li>
<li>创建索引</li>
</ul>
<h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5.使用"></a>5.使用</h2><p><strong>create</strong> <strong>user</strong> ‘ua‘@’%’ identified <strong>by</strong> ‘pa’; 创建用户（ua）和密码（pa）</p>
<p><strong>grant</strong> <strong>all</strong> privileges <strong>on</strong> <em>.</em> <strong>to</strong> ‘ua‘@’%’ <strong>with</strong> <strong>grant</strong> option; 全局权限</p>
<blockquote>
<p>注意： 对于一个已经存在的连接，它的全局权限不受 grant 命令的影响</p>
</blockquote>
<p><strong>revoke</strong> <strong>all</strong> privileges <strong>on</strong> <em>.</em> <strong>from</strong> ‘ua‘@’%’; 收回权限</p>
<h3 id="5-1-Db权限"><a href="#5-1-Db权限" class="headerlink" title="5.1 Db权限"></a>5.1 Db权限</h3><p><strong>grant</strong> <strong>all</strong> privileges <strong>on</strong> db1.* <strong>to</strong> ‘ua‘@’%’ <strong>with</strong> <strong>grant</strong> option;</p>
<blockquote>
<p>grant 修改 db 权限的时候，是同时对磁盘和内存生效的</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2023/02/22/kafak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/22/kafak/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-22 17:16:51" itemprop="dateCreated datePublished" datetime="2023-02-22T17:16:51+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-20 17:34:43" itemprop="dateModified" datetime="2023-02-20T17:34:43+08:00">2023-02-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><blockquote>
<p>多副本机制</p>
</blockquote>
<p>主副本和从副本，从副本只负责同步主副本数据，只有主副本进行读写。</p>
<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>网络结构设计</p>
<p>多路复用</p>
<p>多selector -&gt; 多线程-&gt; 多队列 </p>
<h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ul>
<li>把数据先写入os cache</li>
<li>然后顺序写入磁盘</li>
</ul>
<h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><ul>
<li>根据稀疏索引快速定位到要消费消息</li>
<li>零拷贝机制，减少上下文切换和cpu拷贝</li>
</ul>
<h2 id="如何提高吞吐量"><a href="#如何提高吞吐量" class="headerlink" title="如何提高吞吐量"></a>如何提高吞吐量</h2><ul>
<li>设置缓存区数据量</li>
<li>开启压缩</li>
<li>设置合适批大小batch.size， 太小网络请求频繁，太大导致发送消息慢</li>
</ul>
<h2 id="重试机制带来问题"><a href="#重试机制带来问题" class="headerlink" title="重试机制带来问题"></a>重试机制带来问题</h2><ul>
<li>消息会重复： 幂等支持</li>
<li>消息乱序：  <code>max.in.flight.requests.per.connection</code>&#x3D;1  producer 同一时间只能发送一条消息，默认重试间隔： <code>retry.backoff.ms</code>&#x3D;100</li>
</ul>
<h2 id="偏移量管理"><a href="#偏移量管理" class="headerlink" title="偏移量管理"></a>偏移量管理</h2><p>每个consumer内存里数据结构保存对每个topic的每个分区的消费offset，定期会提交offset,老kafak写入<code>zookeeper</code>（废弃）。</p>
<p>提交offset发送给<code>kafka</code>内部topic：__consumer_offsets，提交过去的时候， key是<code>group.id</code>+topic+分区号，value就是当前offset的值，每隔一段时间，<code>kafka</code>内部会对这个topic进行compact(合并)，也就是每个<code>group.id</code>+topic+分区号就保留最新数据</p>
<h2 id="消费异常感知"><a href="#消费异常感知" class="headerlink" title="消费异常感知"></a>消费异常感知</h2><ul>
<li><code>heartbeat.interval.ms：consumer</code>心跳时间间隔，必须得与coordinator保持心跳才能知道consumer是否故障了， 然后如果故障之后，就会通过心跳下发<code>rebalance</code>的指令给其他的consumer通知他们进行<code>rebalance</code>的操作</li>
<li><code>session.timeout.ms</code>：<code>kafka</code>多长时间感知不到一个consumer就认为他故障了，默认是10</li>
<li><code>max.poll.interval.ms</code>：如果在两次poll操作之间，超过了这个时间，那么就会认为这个consume处理能力太弱了，会被踢出消费组，分区分配给别人去消费，一般来说结合业务处理的性能来设置就可以了。</li>
</ul>
<h2 id="消费者是如何实现rebalance的？"><a href="#消费者是如何实现rebalance的？" class="headerlink" title="消费者是如何实现rebalance的？"></a>消费者是如何实现rebalance的？</h2><blockquote>
<p>根据coordinator实现</p>
</blockquote>
<ul>
<li><ol>
<li>什么是coordinator 每个consumer group都会选择一个broker作为自己的coordinator，他是负责监控这个消费组里的各个消费者的心跳，以及判断是否宕机，然后开启rebalance的</li>
</ol>
</li>
<li><p>如何选择coordinator机器 首先对groupId进行hash（数字），接着对__consumer_offsets的分区数量取模，默认是50，_consumer_offsets的分区数可以通过offsets.topic.num.partitions来设置，找到分区以后，这个分区所在的broker机器就是coordinator机器。比如说：groupId，“myconsumer_group” -&gt; hash值（数字）-&gt; 对50取模 -&gt; 8 __consumer_offsets 这个主题的8号分区在哪台broker上面，那一台就是coordinator 就知道这个consumer group下的所有的消费者提交offset的时候是往哪个分区去提交offset，</p>
</li>
<li><p>(1)每个consumer都发送<code>JoinGroup</code>请求到Coordinator,然后Coordinator从一个consumer group中选择一个consumer作为leader(第一个)，Coordinator把consumer group情况发送给这个leader，leader定制消费方案，通过SyncGroup发给Coordinator，接着Coordinator就把消费方案下发给各个consumer，他们会从指定的分区的 leader broker开始进行socket连接以及消费消息。</p>
</li>
</ul>
<h2 id="谈谈Kafka客户端如何巧妙解决JVM-GC问题？"><a href="#谈谈Kafka客户端如何巧妙解决JVM-GC问题？" class="headerlink" title="谈谈Kafka客户端如何巧妙解决JVM GC问题？"></a>谈谈Kafka客户端如何巧妙解决JVM GC问题？</h2><h3 id="1-Kafka-客户端缓冲机制"><a href="#1-Kafka-客户端缓冲机制" class="headerlink" title="1. Kafka 客户端缓冲机制"></a>1. <strong>Kafka 客户端缓冲机制</strong></h3><p>kafak Produer 流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1）进行 Producer 初始化，加载配置参数，开启网络线程。</span><br><span class="line"></span><br><span class="line">2）执行拦截器逻辑，预处理消息, 封装 Producer Record。</span><br><span class="line"></span><br><span class="line">3）调用 Serializer.serialize() 方法进行消息的 key/value 序列化。</span><br><span class="line"></span><br><span class="line">4）调用 partition() 选择合适的分区策略，给消息体 Producer Record 分配要发送的 Topic 分区号。</span><br><span class="line"></span><br><span class="line">5）从 Kafka Broker 集群获取集群元数据 metadata。</span><br><span class="line"></span><br><span class="line">6）将消息缓存到 RecordAccumulator 收集器中, 最后判断是否要发送。这个加入消息收集器，首先得从 Deque&lt;RecordBatch&gt; 里找到自己的目标分区，如果没有就新建一个 Batch 消息 Deque 加进入。</span><br><span class="line"></span><br><span class="line">7）当达到发送阈值，唤醒 Sender 线程，实例化 NetWorkClient 将 batch record 转换成 request client 的发送消息体, 并将待发送的数据按 【Broker Id &lt;=&gt; List】的数据进行归类。</span><br><span class="line"></span><br><span class="line">8）与服务端不同的 Broker 建立网络连接，将对应 Broker 待发送的消息 List 发送出去。</span><br><span class="line"></span><br><span class="line">9）批次发送的条件为: 缓冲区数据大小达到 batch.size 或者 linger.ms 达到上限，哪个先达到就算哪个。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Kafka 实现的缓冲机制</strong> ,减少垃圾回收，降低STW</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 Kafka 客户端内部，针对这个问题实现了一个非常优秀的机制，就是「缓冲池机制」。即每个 Batch 底层都对应一块内存空间，这个内存空间就是专门用来存放写进去的消息。</span><br><span class="line"></span><br><span class="line">当一个 Batch 数据被发送到了 kafka 服务端，这个 Batch 的内存空间不再使用了。此时这个 Batch 底层的内存空间先不交给 JVM 去垃圾回收，而是把这块内存空间给放入一个缓冲池里。</span><br><span class="line"></span><br><span class="line">这个缓冲池里存放了很多块内存空间，下次如果有一个新的 Batch 数据了，那么直接从缓冲池获取一块内存空间是不是就可以了？然后如果一个 Batch 数据发送出去了之后，再把内存空间还回来是不是就可以了？以此类推，循环往复。</span><br></pre></td></tr></table></figure>

<h2 id="kafka开启精确发送一次"><a href="#kafka开启精确发送一次" class="headerlink" title="kafka开启精确发送一次"></a><code>kafka</code>开启精确发送一次</h2><p>通过引入「<code>PID</code>及Sequence Number」支持幂等性，保证精确一次「exactly once」语义。</p>
<p>其中启用幂等传递的方法配置：<code>enable.idempotence</code> &#x3D; true。启用事务支持的方法配置：设置属性 <code>transcational.id </code>&#x3D; “指定值”。</p>
<h2 id="谈谈你对Kafka控制器及选举机制是如何理解"><a href="#谈谈你对Kafka控制器及选举机制是如何理解" class="headerlink" title="谈谈你对Kafka控制器及选举机制是如何理解"></a>谈谈你对Kafka控制器及选举机制是如何理解</h2><p>所谓的控制器「Controller」就是通过 ZooKeeper 来管理和协调整个 Kafka 集群的组件。集群中任意一台 Broker 都可以充当控制器的角色，但是在正常运行过程中，只能有一个 Broker 成为控制器。</p>
<p>控制器的职责主要包括：</p>
<p>1）集群元信息管理及更新同步 (Topic路由信息等)。</p>
<p>2）主题管理（创建、删除、增加分区等）。</p>
<p>3）分区重新分配。</p>
<p>4）副本故障转移、 Leader 选举、ISR 变更。</p>
<p>5）集群成员管理（通过 watch 机制自动检测新增 Broker、Broker 主动关闭、Broker 宕机等）。</p>
<p>在2.x中 zookeeper作用： 帮助kafka选择controller ，通知controller节点关闭或者加入</p>
<p>Kafka 3.X 版本中，内部实现一个类似于 Raft 的共识算法来选举 Controller</p>
<h2 id="HW-和LEO-理解"><a href="#HW-和LEO-理解" class="headerlink" title="HW 和LEO 理解"></a>HW 和LEO 理解</h2><p>HW 作用：</p>
<p>1）用来标识分区下的哪些消息是可以被消费者消费的。</p>
<p>2）协助 Kafka 完成副本数据同步。</p>
<p>LEO 作用：</p>
<p>1）如果 Follower 和 Leader 的 LEO 数据同步了, 那么 HW 就可以更新了。</p>
<p>2）HW 之前的消息数据对消费者是可见的，属于 commited 状态,  HW 之后的消息数据对消费者是不可见的。</p>
<h2 id="谈谈-Kafka-消息分配策略都有哪些？"><a href="#谈谈-Kafka-消息分配策略都有哪些？" class="headerlink" title="谈谈 Kafka 消息分配策略都有哪些？"></a>谈谈 Kafka 消息分配策略都有哪些？</h2><ul>
<li><p>RangeAssignor 是 Kafka 默认的分区分配算法，它是按照 Topic 的维度进行分配的，首先对 每个Topic 的 Partition 按照分区ID进行排序，然后对订阅该 Topic 的 Consumer Group 的 Consumer 按名称字典进行排序，之后尽量均衡的按照范围区段将分区分配给 Consumer。此时也可能会造成先分配分区的 Consumer 任务过重（分区数无法被消费者数量整除）</p>
</li>
<li><p>RoundRobinAssignor： </p>
</li>
<li><p>该分区分配策略是将 Consumer Group 订阅的所有 Topic 的 Partition 及所有 Consumer 按照字典进行排序后尽量均衡的挨个进行分配。如果 Consumer Group 内，每个 Consumer 订阅都订阅了相同的Topic，那么分配结果是均衡的。如果订阅 Topic 是不同的，那么分配结果是不保证「 尽量均衡」的，因为某些 Consumer 可能不参与一些 Topic 的分配</p>
</li>
<li><p>StickyAssignor</p>
<p>该分区分配算法是最复杂的一种，可以通过 partition.assignment.strategy 参数去设置，从 0.11 版本开始引入，目的就是在执行新分配时，尽量在上一次分配结果上少做调整，其主要实现了以下2个目标：</p>
<p>1、Topic Partition 的分配要尽量均衡。</p>
<p>2、当 Rebalance 发生时，尽量与上一次分配结果保持一致。</p>
</li>
</ul>
<h2 id="Rebalance-触发后如何通知其他-Consumer-进程？"><a href="#Rebalance-触发后如何通知其他-Consumer-进程？" class="headerlink" title="Rebalance 触发后如何通知其他 Consumer 进程？"></a>Rebalance 触发后如何通知其他 Consumer 进程？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rebalance 的通知机制就是靠 Consumer 端的心跳线程，它会定期发送心跳请求到 Broker 端的 Coordinator 协调者组件,当协调者决定开启 Rebalance 后，它会将「REBALANCE_IN_PROGRESS」封装进心跳请求的响应中发送给 Consumer ,当 Consumer 发现心跳响应中包含了「REBALANCE_IN_PROGRESS」，就知道是 Rebalance 开始了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="谈谈Kafka线上大量消息积压你是如何处理的？"><a href="#谈谈Kafka线上大量消息积压你是如何处理的？" class="headerlink" title="谈谈Kafka线上大量消息积压你是如何处理的？"></a>谈谈Kafka线上大量消息积压你是如何处理的？</h2><p>事前：</p>
<ul>
<li>避免大消息发送</li>
<li>分区数和消费组数尽量相等</li>
<li>优化消费端逻辑，避免重平衡</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2023/02/22/jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/22/jvm/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-22 17:16:51" itemprop="dateCreated datePublished" datetime="2023-02-22T17:16:51+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-14 15:00:21" itemprop="dateModified" datetime="2023-02-14T15:00:21+08:00">2023-02-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-工具"><a href="#1-工具" class="headerlink" title="1.工具"></a>1.工具</h2><ul>
<li><p>jps</p>
</li>
<li><p>jinfo ： 查看配置</p>
</li>
<li><p>jvisualvm</p>
</li>
<li><p>jconsole</p>
<h3 id="1-1-jmap"><a href="#1-1-jmap" class="headerlink" title="1.1 jmap"></a>1.1 jmap</h3><blockquote>
<p> jmap [options] pid</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to print class loader statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure>



<h3 id="1-2-jstack"><a href="#1-2-jstack" class="headerlink" title="1.2 jstack"></a>1.2 jstack</h3><h3 id="1-3-jmap"><a href="#1-3-jmap" class="headerlink" title="1.3 jmap"></a>1.3 jmap</h3></li>
</ul>
<h2 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2. 垃圾回收"></a>2. 垃圾回收</h2><p>我们进行MinorGC，会不会有对象被老年代引用着？进行OldGC会不会又有对象被年轻代引用着？</p>
<p>那我们进行MinorGC的时候不光要管GC Roots，还有再去遍历老年代，这个性能问题就很大了。</p>
<p>解决方案： </p>
<p><strong>跨代引用相对于同代引用来说仅占极少数</strong>。</p>
<p>由此就产生了一个新的解决方案，我们不用去扫描整个老年代了，只要在年轻代建立一个数据结构，叫做记忆集Remembered Set，他把老年代划分为N个区域，标志出哪个区域会存在跨代引用。以后在进行MinorGC的时候，只要把这些包含了跨代引用的内存区域加入GC Roots一起扫描就行了。</p>
<p>卡表实际上就是记忆集的一种实现方式，如果说记忆集是接口的话，那么卡表就是他的实现类。</p>
<p>实际上卡表就是映射了一块块的内存地址，这些内存地址块称为<strong>卡页</strong></p>
<p>只要一个卡页内的对象存在一个或者多个跨代对象指针，就将该位置的卡表数组元素修改为1，表示这个位置为脏，没有则为0。</p>
<p>在GC的时候，就直接把值为1对应的卡页对象指针加入GC Roots一起扫描即可。</p>
<p><strong>三色标记</strong></p>
<ol>
<li>白色，在刚开始遍历的时候，所有的对象都是白色的</li>
<li>灰色，被垃圾回收器扫描过，但是至少还有一个引用没有被扫描</li>
<li>黑色，被垃圾回收器扫描过，并且这个对象的引用也全部都被扫描过，是安全存活的对象</li>
</ol>
<p><strong>三色标记的问题</strong></p>
<p>存活对象标记成需要清理，同时满足一下两种场景才会出现</p>
<ol>
<li>插入了一条或者多条黑色到白色对象的引用</li>
<li>删除了全部从灰色到白色对象的引用</li>
</ol>
<p>决绝方案：</p>
<p> <strong>增量更新</strong>和<strong>原始快照</strong> ： CMS使用的是增量更新，而像G1则是使用原始快照</p>
<p> 增量更新解决方案就是，他会把这些新插入的引用记录下来，扫描结束之后，再以黑色对象为根重新扫描一次。</p>
<p> 原始快照则是去破坏第二个条件，他把这个要删除的引用记录下来，扫描结束之后，以灰色对象为根重新扫描一次。所以就像是快照一样，不管你删没删，其实最终还是会按照之前的关系重新来一次</p>
<p><strong>G1使用场景</strong>：</p>
<p>1、50%以上的堆被存活对象占用：当大多数对象都存活的时候，说明老年代被占用的比例也会很大，这个时候就会触发full gc，full gc是很慢的，如果我们使用G1，那么G1就会触发mixed gc，而且mixed gc的GC最大停顿时间还是可控的。<br>2、对象分配和晋升的速度变化非常大：说明了对象往老年代挪动的频率很频繁，一样的，可以减少full gc的发生。<br>3、垃圾回收时间特别长，超过1秒：可以设置停顿时间，提升用户体验。<br>4、8GB以上的堆内存(建议值)：内存如果在8G以下，收集的垃圾不是很多，而G1的算法相对于CMS较为复杂，还很有可能效率不如CMS，但是对于大内存，STW时间比较长，所以，在可控停顿时间这里，G1比较合适。<br>5、停顿时间是500ms以内：停顿时间可由用户控制。</p>
<p><strong>为什么CMS用增量更新，G1用原始快照（SATB）</strong></p>
<ol>
<li>因为增量更新之后会重新深度扫描，G1是以region的方式存储对象，而CMS是以一个连续的老年代存储对象，G1会涉及到跨代扫描，G1的代价相对于CMS要高。</li>
<li>而且G1较CMS更强调用户体验，重新深度扫描会加大STW时间，所以G1选择原始快照。</li>
</ol>
<h2 id="3-调优"><a href="#3-调优" class="headerlink" title="3.调优"></a>3.调优</h2><h3 id="3-1-JVM调优的时机"><a href="#3-1-JVM调优的时机" class="headerlink" title="3.1  JVM调优的时机"></a>3.1  JVM调优的时机</h3><ul>
<li>Heap内存（老年代）持续上涨达到设置的最大内存值；</li>
<li>Full GC 次数频繁；</li>
<li>GC 停顿时间过长（超过1秒）；</li>
<li>应用出现OutOfMemory 等内存异常；</li>
<li>应用中有使用本地缓存且占用大量内存空间；</li>
<li>系统吞吐量与响应性能不高或下降。</li>
</ul>
<h3 id="3-2-JVM调优的目标"><a href="#3-2-JVM调优的目标" class="headerlink" title="3.2  JVM调优的目标"></a>3.2  <strong>JVM调优的目标</strong></h3><ul>
<li>延迟：GC低停顿和GC低频率；</li>
<li>低内存占用；</li>
<li>高吞吐量;</li>
</ul>
<h3 id="2-3-JVM调优的步骤"><a href="#2-3-JVM调优的步骤" class="headerlink" title="2.3 JVM调优的步骤"></a>2.3 <strong>JVM调优的步骤</strong></h3><ul>
<li>分析系统系统运行情况：分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</li>
<li>确定JVM调优量化目标；</li>
<li>确定JVM调优参数（根据历史JVM参数来调整）；</li>
<li>依次确定调优内存、延迟、吞吐量等指标；</li>
<li>对比观察调优前后的差异；</li>
<li>不断的分析和调整，直到找到合适的JVM参数配置；</li>
<li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</li>
</ul>
<h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4.问题"></a>4.问题</h2><h3 id="4-1-为什么用元空间替代永久代"><a href="#4-1-为什么用元空间替代永久代" class="headerlink" title="4.1 为什么用元空间替代永久代?"></a>4.1 为什么用元空间替代永久代?</h3><ul>
<li>降低OOM</li>
<li>降低维护成本，元空间采取本地内存，不需要单独调优参数</li>
</ul>
<p>​     永久代和元空间都是 HotSpot 虚拟机对《Java 虚拟机规范》中方法区的实现，在 JDK 1.8 之前 HotSpot 是使用永久代来实现方法区的，但这样会导致 JVM 调优比较困难，且容易发生 OOM 的问题，而 JDK 1.8 及之后，使用的是元空间存放在本地内存中的方式来替代永久代的，这样就降低了 OOM 发生的可能性，也是 JRockit 和 HotSpot 融合之后的改动之一。</p>
<ol>
<li>JDK 1.6 及之前：方法区使用永久代实现，<strong>静态变量存放在永久代</strong>；</li>
<li>JDK 1.7 ：“去永久代”的前置版本，还存在永久代，不过<strong>已经将字符串常量池和静态变量从永久代移到了堆上</strong>；</li>
<li>JDK 1.8 及以后：<strong>无永久代，使用元空间（存放在本地内存中）实现方法区，常量保存在元空间，但字符串常量池和静态变量依然保存在堆中</strong>。</li>
</ol>
<h3 id="4-2-CMS"><a href="#4-2-CMS" class="headerlink" title="4.2 CMS"></a>4.2 CMS</h3><ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>CMS缺点：</p>
<p>   吞吐量低，<strong>对 CPU 资源消耗较大</strong> ,无法处理浮动垃圾(漏标+并发清除阶段产生)，采用标记清除算法产生内存碎片，并发模式失败后切换 seria old</p>
<h2 id="5-G1-垃圾回收器"><a href="#5-G1-垃圾回收器" class="headerlink" title="5.G1 垃圾回收器"></a>5.G1 垃圾回收器</h2><p><strong>第一种：年轻代垃圾回收 YoungGC</strong></p>
<p>YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC。</p>
<p><strong>第二种，混合垃圾回收，MixedGC</strong></p>
<p>不是FullGC，老年代的堆占有率达到设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及<strong>大对象区</strong>，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现<strong>没有足够的空region</strong>能够承载拷贝对象就会触发一次Full GC。</p>
<p><strong>第三种，Full GC</strong></p>
<p>停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了</p>
<h3 id="4-1-G1垃圾收集器优化建议"><a href="#4-1-G1垃圾收集器优化建议" class="headerlink" title="4.1 G1垃圾收集器优化建议"></a>4.1 <strong>G1垃圾收集器优化建议</strong></h3><p>   调优  -XX:MaxGCPauseMills 时间，避免频繁youngGC 和 大量对象快速进入老年代。</p>
<h2 id="5-实际使用jvm调优配置参考"><a href="#5-实际使用jvm调优配置参考" class="headerlink" title="5.实际使用jvm调优配置参考"></a>5.实际使用jvm调优配置参考</h2><p><strong>2.1 通用型:</strong></p>
<p>开发(模板4)+测试(模板4)+预发(模板2)+生产(模板2)</p>
<p><strong>2.2 并发型:</strong></p>
<p>开发(模板3)+测试(模板3)+预发(模板1)+生产(模板1)</p>
<p><strong>2.3 IO密集型(测试中,如需配置请联系架构师评估):</strong></p>
<p>开发(模板3)+测试(模板3)+预发(模板5)+生产(模板5)</p>
<p><strong>3 ParNew+CMS垃圾回收器模板</strong></p>
<p><strong>模板1:Pod:CPU request:256m limit:2048m;内存 request:3584M limit 4096M ;弹性伸缩 CPU:480%</strong></p>
<p>-Xms2560M -Xmx2560M -Xmn1920M -XX:MetaspaceSize&#x3D;256M -XX:MaxMetaspaceSize&#x3D;256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction&#x3D;92 -XX:+CMSScavengeBeforeRemark</p>
<p><strong>模板2:Pod:CPU request:256m limit:1024m;内存 request:1536M limit 2048M;弹性伸缩 CPU:240%(常规配置,limit*0.6的位置弹性)</strong></p>
<p>-Xms1024M -Xmx1024M -Xmn768M -XX:MetaspaceSize&#x3D;256M -XX:MaxMetaspaceSize&#x3D;256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction&#x3D;92 -XX:+CMSScavengeBeforeRemark</p>
<p><strong>模板3:Pod:CPU request:128m limit:512m;内存 request:768M limit 1024M;弹性伸缩 CPU:240%</strong></p>
<p>-Xms448M -Xmx448M -Xmn336M -XX:SurvivorRatio&#x3D;4 -XX:MetaspaceSize&#x3D;256M -XX:MaxMetaspaceSize&#x3D;256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction&#x3D;92 -XX:+CMSScavengeBeforeRemark</p>
<p><strong>模板4:Pod:CPU request:128m limit:512m;内存 request:640M limit 1024M;弹性伸缩 CPU:240%</strong></p>
<p>-Xms384M -Xmx384M -Xmn288M -XX:SurvivorRatio&#x3D;4 -XX:MetaspaceSize&#x3D;256M -XX:MaxMetaspaceSize&#x3D;256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction&#x3D;92 -XX:+CMSScavengeBeforeRemark</p>
<p><strong>模板5:Pod:CPU request:1024m limit:4096m;内存 request:6144M limit 8192M;弹性伸缩 CPU:240%</strong></p>
<p>-Xms6144M -Xmx6144M -Xmn4608M -XX:MetaspaceSize&#x3D;256M -XX:MaxMetaspaceSize&#x3D;256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction&#x3D;92 -XX:+CMSScavengeBeforeRemark</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2023/02/22/Java%E7%89%88gRPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/22/Java%E7%89%88gRPC/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-22 17:16:51" itemprop="dateCreated datePublished" datetime="2023-02-22T17:16:51+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-12 16:02:45" itemprop="dateModified" datetime="2022-12-12T16:02:45+08:00">2022-12-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-安装protocbuf"><a href="#1-安装protocbuf" class="headerlink" title="1.安装protocbuf"></a>1.安装protocbuf</h2><ol>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/protocolbuffers/protobuf/releases/tag/v3.19.1">下载protobuf</a> window版</p>
</li>
<li><p>配置环境变量：</p>
</li>
</ol>
<p><code>变量名</code>：PROTOCBUF_HOME</p>
<p><code>变量值</code>：D:\protoc-3.19.1-win64</p>
<p>找到系统变量中的<code>path</code>变量，选中后点击<code>编辑</code>，在<code>新建</code>的内容中输入：%PROTOBUF_HOME%\bin</p>
<ol start="3">
<li>idea安装protocbuf插件</li>
</ol>
<h2 id="2-gRPC项目构建"><a href="#2-gRPC项目构建" class="headerlink" title="2. gRPC项目构建"></a>2. gRPC项目构建</h2><h3 id="1-插件"><a href="#1-插件" class="headerlink" title="1. 插件"></a>1. 插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;extensions&gt;</span><br><span class="line">    &lt;extension&gt;</span><br><span class="line">      &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.6.2&lt;/version&gt;</span><br><span class="line">    &lt;/extension&gt;</span><br><span class="line">  &lt;/extensions&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.6.1&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;protocArtifact&gt;com.google.protobuf:protoc:3.17.3:exe:$&#123;os.detected.classifier&#125;&lt;/protocArtifact&gt;</span><br><span class="line">        &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;</span><br><span class="line">        &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.42.0:exe:$&#123;os.detected.classifier&#125;&lt;/pluginArtifact&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">            &lt;goal&gt;compile-custom&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-netty-shaded&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.42.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-protobuf&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.42.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-stub&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.42.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt; &lt;!-- necessary for Java 9+ --&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;annotations-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;6.0.53&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-添加-proto文件"><a href="#2-添加-proto文件" class="headerlink" title="2. 添加.proto文件"></a>2. 添加.proto文件</h3><p>  一定要在和src&#x2F;main&#x2F;java源文件目录同级的proto源文件目录才可以。 </p>
<p>helloworld.proto</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; // 协议版本</span><br><span class="line"></span><br><span class="line">// 选项配置</span><br><span class="line">option java_package = &quot;com.cgh.protobuf&quot;;</span><br><span class="line">option java_outer_classname = &quot;RPCDateServiceApi&quot;;</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line"></span><br><span class="line">// 定义包名</span><br><span class="line">package com.cgh.protobuf;</span><br><span class="line"></span><br><span class="line">// 服务接口.定义请求参数和相应结果</span><br><span class="line">service RPCDateService &#123;</span><br><span class="line">  rpc getDate (RPCDateRequest) returns (RPCDateResponse) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义请求体</span><br><span class="line">message RPCDateRequest &#123;</span><br><span class="line">  string userName = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义响应内容</span><br><span class="line">message RPCDateResponse &#123;</span><br><span class="line">  string serverDate = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-用插件根据-proto文件生成消息体类文件和XXXGrpc类文件"><a href="#3-用插件根据-proto文件生成消息体类文件和XXXGrpc类文件" class="headerlink" title="3. 用插件根据.proto文件生成消息体类文件和XXXGrpc类文件"></a>3. 用插件根据.proto文件生成消息体类文件和XXXGrpc类文件</h3><ul>
<li><code>mvn protobuf:compile</code> 生成消息体类文件  （多次执行可能失败）</li>
<li><code>mvn protobuf:compile-custom</code> 生成XXXGrpc类文件  （多次执行可能失败)</li>
<li>把生成的消息体文件和 XXXGrpc 文件copy到项目</li>
</ul>
<h3 id="4-编写实现类"><a href="#4-编写实现类" class="headerlink" title="4. 编写实现类"></a>4. 编写实现类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import com.cgh.protobuf.RPCDateRequest;</span><br><span class="line">import com.cgh.protobuf.RPCDateResponse;</span><br><span class="line">import com.cgh.protobuf.RPCDateServiceGrpc;</span><br><span class="line">import io.grpc.stub.StreamObserver;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line">public class RPCDateServiceImpl extends RPCDateServiceGrpc.RPCDateServiceImplBase &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getDate(RPCDateRequest request, StreamObserver&lt;RPCDateResponse&gt; responseObserver) &#123;</span><br><span class="line">        //请求结果，我们定义的</span><br><span class="line">        RPCDateResponse rpcDateResponse = null;</span><br><span class="line">        //</span><br><span class="line">        String userName = request.getUserName();</span><br><span class="line">        String response = String.format(&quot;你好:%s,今天是%s.&quot;, userName, LocalDate.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;)));</span><br><span class="line">        try &#123;</span><br><span class="line">            // 定义响应,是一个builder构造器.</span><br><span class="line">            rpcDateResponse = RPCDateResponse.newBuilder()</span><br><span class="line">                    .setServerDate(response)</span><br><span class="line">                    .build();</span><br><span class="line">            //int i = 10/0;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            responseObserver.onError(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">            responseObserver.onNext(rpcDateResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-定义服务端"><a href="#5-定义服务端" class="headerlink" title="5. 定义服务端"></a>5. 定义服务端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GRPCServer &#123;</span><br><span class="line">    private static final int port = 9999;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">        //设置service端口</span><br><span class="line">        Server server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService(new RPCDateServiceImpl())</span><br><span class="line">                .build().start();</span><br><span class="line">        System.out.println(String.format(&quot;GRpc服务端启动成功, 端口号: %d.&quot;, port));</span><br><span class="line"></span><br><span class="line">        server.awaitTermination();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-定义客户端"><a href="#6-定义客户端" class="headerlink" title="6. 定义客户端"></a>6. 定义客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static final String host = &quot;localhost&quot;;</span><br><span class="line">    private static final int serverPort = 9999;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1,拿到一个通信channel</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(host, serverPort).</span><br><span class="line">                usePlaintext()//无需加密或认证</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            //2.拿到stub对象</span><br><span class="line">            RPCDateServiceGrpc.RPCDateServiceBlockingStub rpcDateService  = RPCDateServiceGrpc.newBlockingStub(channel);</span><br><span class="line">            RPCDateRequest rpcDateRequest = RPCDateRequest.newBuilder()</span><br><span class="line">                    .setUserName(&quot;JACK&quot;)</span><br><span class="line">                    .build();</span><br><span class="line">            //3,请求</span><br><span class="line">            RPCDateResponse rpcDateResponse = rpcDateService.getDate(rpcDateRequest);</span><br><span class="line">            //4,输出结果</span><br><span class="line">            System.out.println(rpcDateResponse.getServerDate());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 5.关闭channel, 释放资源.</span><br><span class="line">            channel.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2023/02/22/forkJoin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/22/forkJoin/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-22 17:16:51" itemprop="dateCreated datePublished" datetime="2023-02-22T17:16:51+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-07 17:21:12" itemprop="dateModified" datetime="2023-02-07T17:21:12+08:00">2023-02-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><code>forkJoin</code> 把大任务拆分成小任务，放到不同的队列中，每个队列对应一个线程进行处理</p>
</blockquote>
<p><code>forkJoinTask</code> 三个实现类：</p>
<ul>
<li><p>RecursiveAction</p>
<p>无结果返回的任务</p>
</li>
<li><p>RecursiveTask</p>
<p>有返回结果的任务</p>
</li>
<li><p>CountedCompleter</p>
<p>无返回值任务，完成任务后可以触发回调</p>
</li>
</ul>
<h2 id="工作窃取（-work-stealing-）算法"><a href="#工作窃取（-work-stealing-）算法" class="headerlink" title="工作窃取（ work-stealing ）算法"></a>工作窃取（ work-stealing ）算法</h2><blockquote>
<p>闲的线程试图从繁忙线程的 <code>deques</code> 中 窃取工作</p>
</blockquote>
<p>默认情况下，每个工作线程从其自己的双端队列中获取任务。但如果自己的双端队列中的任务已经执行完毕，双端队列为空时，工作线程就会从另一个忙线程的双端队列尾部或全局入口队列中获取任务，因为这是最大概率可能找到工作的地方</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2023/02/22/fastjson/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/22/fastjson/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-22 17:16:51" itemprop="dateCreated datePublished" datetime="2023-02-22T17:16:51+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-23 15:56:08" itemprop="dateModified" datetime="2023-02-23T15:56:08+08:00">2023-02-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>泛型反序列化</li>
</ol>
<p>​        <code>new TypeReference&lt;List&lt;User&gt;&gt;()</code></p>
<ol start="2">
<li><p>如果数据对象中存在Map对象，为了保证序列化后的字段顺序一致，需要添加<code>SerializerFeature.MapSortField</code>特征。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.toJSONString(userMap, SerializerFeature.MapSortField);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>排除所有类的属性字段：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserVO&gt; userList = ...;SimplePropertyPreFilter filter = new SimplePropertyPreFilter();filter.getExcludes().addAll(Arrays.asList(&quot;gmtCreate&quot;, &quot;gmtModified&quot;));Assert.assertEquals(&quot;用户信息不一致&quot;, text, JSON.toJSONString(user, filter));</span><br></pre></td></tr></table></figure>

<p><strong>排除单个类的属性字段：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserVO&gt; userList = ...;SimplePropertyPreFilter filter = new SimplePropertyPreFilter(UserVO.class);filter.getExcludes().addAll(Arrays.asList(&quot;gmtCreate&quot;, &quot;gmtModified&quot;));Assert.assertEquals(&quot;用户信息不一致&quot;, text, JSON.toJSONString(user, filter));</span><br></pre></td></tr></table></figure>

<p><strong>排查多个类属性：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;UserVO, CompanyVO&gt; userCompanyPair = ...;</span><br><span class="line"><span class="type">SimplePropertyPreFilter</span> <span class="variable">userFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimplePropertyPreFilter</span>(UserVO.class);</span><br><span class="line">userFilter.getExcludes().addAll(Arrays.asList(<span class="string">&quot;gmtCreate&quot;</span>, <span class="string">&quot;gmtModified&quot;</span>));</span><br><span class="line"><span class="type">SimplePropertyPreFilter</span> <span class="variable">companyFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimplePropertyPreFilter</span>(CompanyVO.class);</span><br><span class="line">companyFilter.getExcludes().addAll(Arrays.asList(<span class="string">&quot;createTime&quot;</span>, <span class="string">&quot;modifyTime&quot;</span>));</span><br><span class="line">Assert.assertEquals(<span class="string">&quot;用户公司对不一致&quot;</span>, text, JSON.toJSONString(userCompanyPair, <span class="keyword">new</span> <span class="title class_">SerializeFilter</span>[]&#123;userFilter, companyFilter&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2023/02/22/es/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/22/es/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-22 17:16:51" itemprop="dateCreated datePublished" datetime="2023-02-22T17:16:51+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-19 10:54:52" itemprop="dateModified" datetime="2022-12-19T10:54:52+08:00">2022-12-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-十亿级数据ES搜索怎么优化"><a href="#1-十亿级数据ES搜索怎么优化" class="headerlink" title="1. 十亿级数据ES搜索怎么优化?"></a>1. 十亿级数据ES搜索怎么优化?</h2><blockquote>
<p>es 的搜索引擎严重依赖于底层的 <code>filesystem cache</code>，你如果给 <code>filesystem cache</code> 更多的内存，尽量让内存可以容纳所有的 <code>idx segment file</code> 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高</p>
</blockquote>
<ul>
<li>存尽量少字段  ，可以采用<code>es</code>+<code>hbase</code></li>
<li>数据预热，程序定时刷新数据到 <code>filesystem cache</code></li>
<li>冷热分离 ， 冷热数据单独建立索引，避免冷数据刷掉热数据的<code>filesystem cache</code></li>
<li>直接写入计算好数据，避免join操作</li>
<li>分页性能优化</li>
</ul>
<p>​    es 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p>
<h2 id="2-在数据量很大的情况下，怎么实现深度分页？"><a href="#2-在数据量很大的情况下，怎么实现深度分页？" class="headerlink" title="2. 在数据量很大的情况下，怎么实现深度分页？"></a>2. 在数据量很大的情况下，怎么实现深度分页？</h2><h2 id="3-es-读写数据过程-和检索过程"><a href="#3-es-读写数据过程-和检索过程" class="headerlink" title="3. es 读写数据过程 和检索过程"></a>3. es 读写数据过程 和检索过程</h2><h3 id="1-写"><a href="#1-写" class="headerlink" title="1. 写"></a>1. 写</h3><ul>
<li>客户端选择一个 node 发送请求过去，这个 node 就是 <code>coordinating node</code>（协调节点）。</li>
<li><code>coordinating node</code> 对 document 进行路由，将请求转发给对应的 node（有 primary shard）。</li>
<li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到 <code>replica node</code>。</li>
<li><code>coordinating node</code> 如果发现 <code>primary node</code> 和所有 <code>replica node</code> 都搞定之后，就返回响应结果给客户端。</li>
</ul>
<h3 id="2-读"><a href="#2-读" class="headerlink" title="2. 读"></a>2. 读</h3><p>可以通过 <code>doc id</code> 来查询，会根据 <code>doc id</code> 进行 hash，判断出来当时把 <code>doc id</code> 分配到了哪个 shard 上面去，从那个 shard 去查询。</p>
<ul>
<li>客户端发送请求到任意一个 node，成为 <code>coordinate node</code>。</li>
<li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code>随机轮询算法，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li>
<li>接收请求的 node 返回 document 给 <code>coordinate node</code>。</li>
<li><code>coordinate node</code> 返回 document 给客户端。</li>
</ul>
<h3 id="3-检索"><a href="#3-检索" class="headerlink" title="3.检索"></a>3.检索</h3><p>客户端发送请求到一个 <code>coordinate node</code>。</p>
<p>协调节点将搜索请求转发到所有的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code>，都可以。</p>
<p>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code>）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</p>
<p>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上拉取实际的 <code>document</code> 数据，最终返回给客户端。</p>
<p>​     </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2023/02/22/completaFuture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/22/completaFuture/" class="post-title-link" itemprop="url">completaFuture.md</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-22 17:16:51" itemprop="dateCreated datePublished" datetime="2023-02-22T17:16:51+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-23 15:33:51" itemprop="dateModified" datetime="2023-02-23T15:33:51+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>completaFuture 使用</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/02/22/completaFuture/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2023/02/22/%E6%96%B9%E6%A1%88/%E7%A7%92%E6%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/22/%E6%96%B9%E6%A1%88/%E7%A7%92%E6%9D%80/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-22 17:16:49" itemprop="dateCreated datePublished" datetime="2023-02-22T17:16:49+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-21 17:29:50" itemprop="dateModified" datetime="2023-02-21T17:29:50+08:00">2023-02-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1.架构"></a>1.架构</h2><ul>
<li>接入层，负载均衡： ngnix ：并发度10W+</li>
<li>应用层 tomcat  ： 并发度800</li>
<li>持久层 redis ：5万， mysql  1000</li>
</ul>
<h2 id="2-方案"><a href="#2-方案" class="headerlink" title="2. 方案"></a>2. 方案</h2><ul>
<li><p>系统扩容</p>
</li>
<li><p>读写分离</p>
</li>
<li><p>多级缓存</p>
</li>
<li><p>异步解耦</p>
</li>
<li><p>流量防刷</p>
</li>
<li><p>资源控制</p>
<img src="..\图片\秒杀-网络.png" alt="秒杀-网络" style="zoom:80%;" /></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2023/02/22/%E6%96%B9%E6%A1%88/%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/22/%E6%96%B9%E6%A1%88/%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-22 17:16:49" itemprop="dateCreated datePublished" datetime="2023-02-22T17:16:49+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-20 15:38:42" itemprop="dateModified" datetime="2023-02-20T15:38:42+08:00">2023-02-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-JDK自带的延时队列"><a href="#1-JDK自带的延时队列" class="headerlink" title="1. JDK自带的延时队列"></a>1. JDK自带的延时队列</h2><blockquote>
<p>JDK中提供了一种延迟队列数据结构DelayQueue，其本质是封装了PriorityQueue，可以把元素进行排序。</p>
</blockquote>
<img src="..\.\图片\jdk延迟队列.png" alt="jdk延迟队列" style="zoom: 67%;" />

<ol>
<li>把订单插入DelayQueue中，以超时时间作为排序条件，将订单按照超时时间从小到大排序。</li>
<li>起一个线程不停轮询队列的头部，如果订单的超时时间到了，就出队进行超时处理，并更新订单状态到数据库中。</li>
<li>为了防止机器重启导致内存中的DelayQueue数据丢失，每次机器启动的时候，需要从数据库中初始化未结束的订单，加入到DelayQueue中。</li>
</ol>
<ul>
<li><p>优点：简单，不需要借助其他第三方组件，成本低。</p>
</li>
<li><p>缺点：</p>
</li>
<li><ul>
<li>所有超时处理订单都要加入到DelayQueue中，占用内存大。</li>
<li>没法做到分布式处理，只能在集群中选一台leader专门处理，效率低。</li>
<li>不适合订单量比较大的场景。</li>
</ul>
</li>
</ul>
<h2 id="2-RabbitMQ的延时消息"><a href="#2-RabbitMQ的延时消息" class="headerlink" title="2.RabbitMQ的延时消息"></a>2.RabbitMQ的延时消息</h2><p>RabbitMQ的延时消息主要有两个解决方案：</p>
<ul>
<li>RabbitMQ Delayed Message Plugin</li>
</ul>
<p>​       RabbitMQ Delayed Message Plugin是官方提供的延时消息插件，虽然使用起来比较方便，但是不是高可用的，如果节点挂了会导致消息丢失</p>
<ul>
<li><p>消息的TTL+死信Exchange</p>
</li>
<li><p>TTL：即消息的存活时间。RabbitMQ可以对队列和消息分别设置TTL，如果对队列设置，则队列中所有的消息都具有相同的过期时间。超过了这个时间，我们认为这个消息就死了，称之为死信。</p>
</li>
<li><p>死信Exchange（DLX）：一个消息在满足以下条件会进入死信交换机</p>
</li>
<li><ul>
<li>一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。</li>
<li>TTL到期的消息。</li>
<li>队列满了被丢弃的消息。</li>
</ul>
</li>
<li><img src="..\图片\rabbitMq延时队列实现.png" alt="rabbitMq延时队列实现" style="zoom: 67%;" /></li>
</ul>
<p>​         </p>
<ol>
<li>定义一个BizQueue，用来接收死信消息，并进行业务消费。</li>
<li>定义一个死信交换机(DLXExchange)，绑定BizQueue，接收延时队列的消息，并转发给BizQueue。</li>
<li>定义一组延时队列DelayQueue_xx，分别配置不同的TTL，用来处理固定延时5s、10s、30s等延时等级，并绑定到DLXExchange。</li>
<li>定义DelayExchange，用来接收业务发过来的延时消息，并根据延时时间转发到不同的延时队列中。</li>
</ol>
<ul>
<li><p>优点：可以支持海量延时消息，支持分布式处理。</p>
</li>
<li><p>缺点：</p>
</li>
<li><ul>
<li>不灵活，只能支持固定延时等级。</li>
<li>使用复杂，要配置一堆延时队列。</li>
</ul>
</li>
</ul>
<p>引入文章： <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OmbyxkufVm-XzwIv_A514w">https://mp.weixin.qq.com/s/OmbyxkufVm-XzwIv_A514w</a></p>
<h2 id="3-redis-延迟方案"><a href="#3-redis-延迟方案" class="headerlink" title="3. redis 延迟方案"></a>3. redis 延迟方案</h2><h3 id="3-1-redis-key-过期监听"><a href="#3-1-redis-key-过期监听" class="headerlink" title="3.1 redis  key 过期监听"></a>3.1 redis  key 过期监听</h3><p>​    定期删除（随机选取），惰性删除， 无法保证实时性。</p>
<p>​    Redis过期通知也是不可靠的，Redis在过期通知的时候，如果应用正好重启了，那么就有可能通知事件就丢了。要有其他方案兜底。</p>
<h3 id="3-2-redis-zset-方案"><a href="#3-2-redis-zset-方案" class="headerlink" title="3.2 redis zset 方案"></a>3.2 redis zset 方案</h3><h2 id="4-RocketMQ-方案"><a href="#4-RocketMQ-方案" class="headerlink" title="4 RocketMQ 方案"></a>4 RocketMQ 方案</h2><p>实现原理： 支持18个等级延迟队列，创建18个延迟对应内部topic，为每一个延迟队列开启延迟任务，到期写入真正的topic队列中</p>
<p><img src="/..%5C%E5%9B%BE%E7%89%87%5CRocketMq%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E5%8E%9F%E7%90%86.png" alt="RocketMq延迟消息原理"></p>
<h2 id="5-定时任务分布式批处理"><a href="#5-定时任务分布式批处理" class="headerlink" title="5. 定时任务分布式批处理"></a>5. 定时任务分布式批处理</h2><p>  定时任务分布式批处理解决方案，即通过定时任务不停轮询数据库的订单，将已经超时的订单捞出来，分发给不同的机器分布式处理：</p>
<img src="..\图片\定时任务分布式处理.png" alt="定时任务分布式处理" style="zoom:80%;" />

<p>使用定时任务分布式批处理的方案具有如下优势：</p>
<ul>
<li><strong>稳定性强：</strong>基于通知的方案（比如MQ和Redis），比较担心在各种极端情况下导致通知的事件丢了。使用定时任务跑批，只需要保证业务幂等即可，如果这个批次有些订单没有捞出来，或者处理订单的时候应用重启了，下一个批次还是可以捞出来处理，稳定性非常高。</li>
<li><strong>效率高：</strong>基于MQ的方案，需要一个订单一个定时消息，consumer处理定时消息的时候也需要一个订单一个订单更新，对数据库tps很高。使用定时任务跑批方案，一次捞出一批订单，处理完了，可以批量更新订单状态，减少数据库的tps。在海量订单处理场景下，批量处理效率最高。</li>
<li><strong>可运维：</strong>基于数据库存储，可以很方便的对订单进行修改、暂停、取消等操作，所见即所得。如果业务跑失败了，还可以直接通过sql修改数据库来进行批量运维。</li>
<li><strong>成本低：</strong>相对于其他解决方案要借助第三方存储组件，复用数据库的成本大大降低。</li>
</ul>
<p>但是使用定时任务有个天然的缺点：没法做到精度很高。定时任务的延迟时间，由定时任务的调度周期决定。如果把频率设置很小，就会导致数据库的qps比较高，容易造成数据库压力过大，从而影响线上的正常业务。</p>
<p>所以一般需要抽离出超时中心和超时库来单独做订单的超时调度，在阿里内部，几乎所有的业务都使用<strong>基于定时任务分布式批处理的超时中心来做订单超时处理</strong>，SLA可以做到30秒以内：</p>
<p><img src="/..%5C%E5%9B%BE%E7%89%87%5C%E9%98%BF%E9%87%8C%E8%B7%91%E6%89%B9%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88.png" alt="阿里跑批定时任务方案"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">热心的蚂蚁</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

-->
    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
