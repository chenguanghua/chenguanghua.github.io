<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chenguanghua.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="热心的蚂蚁的博客">
<meta property="og:url" content="https://chenguanghua.github.io/page/3/index.html">
<meta property="og:site_name" content="热心的蚂蚁的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="热心的蚂蚁">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chenguanghua.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>热心的蚂蚁的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">热心的蚂蚁的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/%E9%A6%96%E9%A1%B5" rel="section">首页</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">热心的蚂蚁</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2022/12/15/kafak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/15/kafak/" class="post-title-link" itemprop="url">kafak总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-15 08:14:16" itemprop="dateCreated datePublished" datetime="2022-12-15T08:14:16+08:00">2022-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-23 17:31:29" itemprop="dateModified" datetime="2023-02-23T17:31:29+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><blockquote>
<p>多副本机制</p>
</blockquote>
<p>主副本和从副本，从副本只负责同步主副本数据，只有主副本进行读写。</p>
<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>网络结构设计</p>
<p>多路复用</p>
<p>多selector -&gt; 多线程-&gt; 多队列 </p>
<h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ul>
<li>把数据先写入os cache</li>
<li>然后顺序写入磁盘</li>
</ul>
<h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><ul>
<li>根据稀疏索引快速定位到要消费消息</li>
<li>零拷贝机制，减少上下文切换和cpu拷贝</li>
</ul>
<h2 id="如何提高吞吐量"><a href="#如何提高吞吐量" class="headerlink" title="如何提高吞吐量"></a>如何提高吞吐量</h2><ul>
<li>设置缓存区数据量</li>
<li>开启压缩</li>
<li>设置合适批大小batch.size， 太小网络请求频繁，太大导致发送消息慢</li>
</ul>
<h2 id="重试机制带来问题"><a href="#重试机制带来问题" class="headerlink" title="重试机制带来问题"></a>重试机制带来问题</h2><ul>
<li>消息会重复： 幂等支持</li>
<li>消息乱序：  <code>max.in.flight.requests.per.connection</code>&#x3D;1  producer 同一时间只能发送一条消息，默认重试间隔： <code>retry.backoff.ms</code>&#x3D;100</li>
</ul>
<h2 id="偏移量管理"><a href="#偏移量管理" class="headerlink" title="偏移量管理"></a>偏移量管理</h2><p>每个consumer内存里数据结构保存对每个topic的每个分区的消费offset，定期会提交offset,老kafak写入<code>zookeeper</code>（废弃）。</p>
<p>提交offset发送给<code>kafka</code>内部topic：__consumer_offsets，提交过去的时候， key是<code>group.id</code>+topic+分区号，value就是当前offset的值，每隔一段时间，<code>kafka</code>内部会对这个topic进行compact(合并)，也就是每个<code>group.id</code>+topic+分区号就保留最新数据</p>
<h2 id="消费异常感知"><a href="#消费异常感知" class="headerlink" title="消费异常感知"></a>消费异常感知</h2><ul>
<li><code>heartbeat.interval.ms：consumer</code>心跳时间间隔，必须得与coordinator保持心跳才能知道consumer是否故障了， 然后如果故障之后，就会通过心跳下发<code>rebalance</code>的指令给其他的consumer通知他们进行<code>rebalance</code>的操作</li>
<li><code>session.timeout.ms</code>：<code>kafka</code>多长时间感知不到一个consumer就认为他故障了，默认是10</li>
<li><code>max.poll.interval.ms</code>：如果在两次poll操作之间，超过了这个时间，那么就会认为这个consume处理能力太弱了，会被踢出消费组，分区分配给别人去消费，一般来说结合业务处理的性能来设置就可以了。</li>
</ul>
<h2 id="消费者是如何实现rebalance的？"><a href="#消费者是如何实现rebalance的？" class="headerlink" title="消费者是如何实现rebalance的？"></a>消费者是如何实现rebalance的？</h2><blockquote>
<p>根据coordinator实现</p>
</blockquote>
<ul>
<li><ol>
<li>什么是coordinator 每个consumer group都会选择一个broker作为自己的coordinator，他是负责监控这个消费组里的各个消费者的心跳，以及判断是否宕机，然后开启rebalance的</li>
</ol>
</li>
<li><p>如何选择coordinator机器 首先对groupId进行hash（数字），接着对__consumer_offsets的分区数量取模，默认是50，_consumer_offsets的分区数可以通过offsets.topic.num.partitions来设置，找到分区以后，这个分区所在的broker机器就是coordinator机器。比如说：groupId，“myconsumer_group” -&gt; hash值（数字）-&gt; 对50取模 -&gt; 8 __consumer_offsets 这个主题的8号分区在哪台broker上面，那一台就是coordinator 就知道这个consumer group下的所有的消费者提交offset的时候是往哪个分区去提交offset，</p>
</li>
<li><p>(1)每个consumer都发送<code>JoinGroup</code>请求到Coordinator,然后Coordinator从一个consumer group中选择一个consumer作为leader(第一个)，Coordinator把consumer group情况发送给这个leader，leader定制消费方案，通过SyncGroup发给Coordinator，接着Coordinator就把消费方案下发给各个consumer，他们会从指定的分区的 leader broker开始进行socket连接以及消费消息。</p>
</li>
</ul>
<h2 id="谈谈Kafka客户端如何巧妙解决JVM-GC问题？"><a href="#谈谈Kafka客户端如何巧妙解决JVM-GC问题？" class="headerlink" title="谈谈Kafka客户端如何巧妙解决JVM GC问题？"></a>谈谈Kafka客户端如何巧妙解决JVM GC问题？</h2><h3 id="1-Kafka-客户端缓冲机制"><a href="#1-Kafka-客户端缓冲机制" class="headerlink" title="1. Kafka 客户端缓冲机制"></a>1. <strong>Kafka 客户端缓冲机制</strong></h3><p>kafak Produer 流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1）进行 Producer 初始化，加载配置参数，开启网络线程。</span><br><span class="line"></span><br><span class="line">2）执行拦截器逻辑，预处理消息, 封装 Producer Record。</span><br><span class="line"></span><br><span class="line">3）调用 Serializer.serialize() 方法进行消息的 key/value 序列化。</span><br><span class="line"></span><br><span class="line">4）调用 partition() 选择合适的分区策略，给消息体 Producer Record 分配要发送的 Topic 分区号。</span><br><span class="line"></span><br><span class="line">5）从 Kafka Broker 集群获取集群元数据 metadata。</span><br><span class="line"></span><br><span class="line">6）将消息缓存到 RecordAccumulator 收集器中, 最后判断是否要发送。这个加入消息收集器，首先得从 Deque&lt;RecordBatch&gt; 里找到自己的目标分区，如果没有就新建一个 Batch 消息 Deque 加进入。</span><br><span class="line"></span><br><span class="line">7）当达到发送阈值，唤醒 Sender 线程，实例化 NetWorkClient 将 batch record 转换成 request client 的发送消息体, 并将待发送的数据按 【Broker Id &lt;=&gt; List】的数据进行归类。</span><br><span class="line"></span><br><span class="line">8）与服务端不同的 Broker 建立网络连接，将对应 Broker 待发送的消息 List 发送出去。</span><br><span class="line"></span><br><span class="line">9）批次发送的条件为: 缓冲区数据大小达到 batch.size 或者 linger.ms 达到上限，哪个先达到就算哪个。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Kafka 实现的缓冲机制</strong> ,减少垃圾回收，降低STW</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 Kafka 客户端内部，针对这个问题实现了一个非常优秀的机制，就是「缓冲池机制」。即每个 Batch 底层都对应一块内存空间，这个内存空间就是专门用来存放写进去的消息。</span><br><span class="line"></span><br><span class="line">当一个 Batch 数据被发送到了 kafka 服务端，这个 Batch 的内存空间不再使用了。此时这个 Batch 底层的内存空间先不交给 JVM 去垃圾回收，而是把这块内存空间给放入一个缓冲池里。</span><br><span class="line"></span><br><span class="line">这个缓冲池里存放了很多块内存空间，下次如果有一个新的 Batch 数据了，那么直接从缓冲池获取一块内存空间是不是就可以了？然后如果一个 Batch 数据发送出去了之后，再把内存空间还回来是不是就可以了？以此类推，循环往复。</span><br></pre></td></tr></table></figure>

<h2 id="kafka开启精确发送一次"><a href="#kafka开启精确发送一次" class="headerlink" title="kafka开启精确发送一次"></a><code>kafka</code>开启精确发送一次</h2><p>通过引入「<code>PID</code>及Sequence Number」支持幂等性，保证精确一次「exactly once」语义。</p>
<p>其中启用幂等传递的方法配置：<code>enable.idempotence</code> &#x3D; true。启用事务支持的方法配置：设置属性 <code>transcational.id </code>&#x3D; “指定值”。</p>
<h2 id="谈谈你对Kafka控制器及选举机制是如何理解"><a href="#谈谈你对Kafka控制器及选举机制是如何理解" class="headerlink" title="谈谈你对Kafka控制器及选举机制是如何理解"></a>谈谈你对Kafka控制器及选举机制是如何理解</h2><p>所谓的控制器「Controller」就是通过 ZooKeeper 来管理和协调整个 Kafka 集群的组件。集群中任意一台 Broker 都可以充当控制器的角色，但是在正常运行过程中，只能有一个 Broker 成为控制器。</p>
<p>控制器的职责主要包括：</p>
<p>1）集群元信息管理及更新同步 (Topic路由信息等)。</p>
<p>2）主题管理（创建、删除、增加分区等）。</p>
<p>3）分区重新分配。</p>
<p>4）副本故障转移、 Leader 选举、ISR 变更。</p>
<p>5）集群成员管理（通过 watch 机制自动检测新增 Broker、Broker 主动关闭、Broker 宕机等）。</p>
<p>在2.x中 zookeeper作用： 帮助kafka选择controller ，通知controller节点关闭或者加入</p>
<p>Kafka 3.X 版本中，内部实现一个类似于 Raft 的共识算法来选举 Controller</p>
<h2 id="HW-和LEO-理解"><a href="#HW-和LEO-理解" class="headerlink" title="HW 和LEO 理解"></a>HW 和LEO 理解</h2><p>HW 作用：</p>
<p>1）用来标识分区下的哪些消息是可以被消费者消费的。</p>
<p>2）协助 Kafka 完成副本数据同步。</p>
<p>LEO 作用：</p>
<p>1）如果 Follower 和 Leader 的 LEO 数据同步了, 那么 HW 就可以更新了。</p>
<p>2）HW 之前的消息数据对消费者是可见的，属于 commited 状态,  HW 之后的消息数据对消费者是不可见的。</p>
<h2 id="谈谈-Kafka-消息分配策略都有哪些？"><a href="#谈谈-Kafka-消息分配策略都有哪些？" class="headerlink" title="谈谈 Kafka 消息分配策略都有哪些？"></a>谈谈 Kafka 消息分配策略都有哪些？</h2><ul>
<li><p>RangeAssignor 是 Kafka 默认的分区分配算法，它是按照 Topic 的维度进行分配的，首先对 每个Topic 的 Partition 按照分区ID进行排序，然后对订阅该 Topic 的 Consumer Group 的 Consumer 按名称字典进行排序，之后尽量均衡的按照范围区段将分区分配给 Consumer。此时也可能会造成先分配分区的 Consumer 任务过重（分区数无法被消费者数量整除）</p>
</li>
<li><p>RoundRobinAssignor： </p>
</li>
<li><p>该分区分配策略是将 Consumer Group 订阅的所有 Topic 的 Partition 及所有 Consumer 按照字典进行排序后尽量均衡的挨个进行分配。如果 Consumer Group 内，每个 Consumer 订阅都订阅了相同的Topic，那么分配结果是均衡的。如果订阅 Topic 是不同的，那么分配结果是不保证「 尽量均衡」的，因为某些 Consumer 可能不参与一些 Topic 的分配</p>
</li>
<li><p>StickyAssignor</p>
<p>该分区分配算法是最复杂的一种，可以通过 partition.assignment.strategy 参数去设置，从 0.11 版本开始引入，目的就是在执行新分配时，尽量在上一次分配结果上少做调整，其主要实现了以下2个目标：</p>
<p>1、Topic Partition 的分配要尽量均衡。</p>
<p>2、当 Rebalance 发生时，尽量与上一次分配结果保持一致。</p>
</li>
</ul>
<h2 id="Rebalance-触发后如何通知其他-Consumer-进程？"><a href="#Rebalance-触发后如何通知其他-Consumer-进程？" class="headerlink" title="Rebalance 触发后如何通知其他 Consumer 进程？"></a>Rebalance 触发后如何通知其他 Consumer 进程？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rebalance 的通知机制就是靠 Consumer 端的心跳线程，它会定期发送心跳请求到 Broker 端的 Coordinator 协调者组件,当协调者决定开启 Rebalance 后，它会将「REBALANCE_IN_PROGRESS」封装进心跳请求的响应中发送给 Consumer ,当 Consumer 发现心跳响应中包含了「REBALANCE_IN_PROGRESS」，就知道是 Rebalance 开始了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="谈谈Kafka线上大量消息积压你是如何处理的？"><a href="#谈谈Kafka线上大量消息积压你是如何处理的？" class="headerlink" title="谈谈Kafka线上大量消息积压你是如何处理的？"></a>谈谈Kafka线上大量消息积压你是如何处理的？</h2><p>事前：</p>
<ul>
<li>避免大消息发送</li>
<li>分区数和消费组数尽量相等</li>
<li>优化消费端逻辑，避免重平衡</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2022/09/15/oauth2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/15/oauth2/" class="post-title-link" itemprop="url">oauth2学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-15 08:14:16" itemprop="dateCreated datePublished" datetime="2022-09-15T08:14:16+08:00">2022-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-23 17:38:49" itemprop="dateModified" datetime="2023-02-23T17:38:49+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-角色"><a href="#1-角色" class="headerlink" title="1.  角色"></a>1.  角色</h2><ul>
<li><p><strong>Resource Owner :资源拥有者</strong></p>
</li>
<li><h5 id="Resource-Server-资源服务器"><a href="#Resource-Server-资源服务器" class="headerlink" title="Resource Server 资源服务器"></a>Resource Server 资源服务器</h5></li>
<li><p><strong>Client 客户端</strong></p>
</li>
<li><h5 id="Authorization-server-授权服务器"><a href="#Authorization-server-授权服务器" class="headerlink" title="Authorization server 授权服务器"></a>Authorization server 授权服务器</h5></li>
</ul>
<h2 id="2-大致流程"><a href="#2-大致流程" class="headerlink" title="2  大致流程"></a>2  大致流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--------+                               +---------------+</span><br><span class="line">    |        |--(A)- Authorization Request -&gt;|   Resource    |</span><br><span class="line">    |        |                               |     Owner     |</span><br><span class="line">    |        |&lt;-(B)-- Authorization Grant ---|               |</span><br><span class="line">    |        |                               +---------------+</span><br><span class="line">    |        |</span><br><span class="line">    |        |                               +---------------+</span><br><span class="line">    |        |--(C)-- Authorization Grant --&gt;| Authorization |</span><br><span class="line">    | Client |                               |     Server    |</span><br><span class="line">    |        |&lt;-(D)----- Access Token -------|               |</span><br><span class="line">    |        |                               +---------------+</span><br><span class="line">    |        |</span><br><span class="line">    |        |                               +---------------+</span><br><span class="line">    |        |--(E)----- Access Token ------&gt;|    Resource   |</span><br><span class="line">    |        |                               |     Server    |</span><br><span class="line">    |        |&lt;-(F)--- Protected Resource ---|               |</span><br><span class="line">    +--------+                               +---------------+</span><br></pre></td></tr></table></figure>

<h2 id="3-具体实现方式"><a href="#3-具体实现方式" class="headerlink" title="3 . 具体实现方式"></a>3 . 具体实现方式</h2><h3 id="3-1-授权码模式"><a href="#3-1-授权码模式" class="headerlink" title="3.1  授权码模式"></a>3.1  授权码模式</h3><blockquote>
<p>授权码授予类型是一种安全的方式来获取访问令牌和刷新令牌。它涉及客户端将用户重定向到授权服务器，用户可以授予客户端访问其资源的权限。然后，授权服务器将授权码发送回客户端，可以用来兑换访问令牌。然后，可以使用访问令牌来访问用户的资源。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">     | Resource |</span><br><span class="line">     |   Owner  |</span><br><span class="line">     |          |</span><br><span class="line">     +----------+</span><br><span class="line">          ^</span><br><span class="line">          |</span><br><span class="line">         (B)</span><br><span class="line">     +----|-----+          Client Identifier      +---------------+</span><br><span class="line">     |         -+----(A)-- &amp; Redirection URI ----&gt;|               |</span><br><span class="line">     |  User-   |                                 | Authorization |</span><br><span class="line">     |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |</span><br><span class="line">     |          |                                 |               |</span><br><span class="line">     |         -+----(C)-- Authorization Code ---&lt;|               |</span><br><span class="line">     +-|----|---+                                 +---------------+</span><br><span class="line">       |    |                                         ^      v</span><br><span class="line">      (A)  (C)                                        |      |</span><br><span class="line">       |    |                                         |      |</span><br><span class="line">       ^    v                                         |      |</span><br><span class="line">     +---------+                                      |      |</span><br><span class="line">     |         |&gt;---(D)-- Authorization Code ---------<span class="string">&#x27;      |</span></span><br><span class="line"><span class="string">     |  Client |          &amp; Redirection URI                  |</span></span><br><span class="line"><span class="string">     |         |                                             |</span></span><br><span class="line"><span class="string">     |         |&lt;---(E)----- Access Token -------------------&#x27;</span></span><br><span class="line">     +---------+       (w/ Optional Refresh Token)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2022/08/15/Java%E7%89%88gRPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/Java%E7%89%88gRPC/" class="post-title-link" itemprop="url">gRPc实例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-15 08:14:16" itemprop="dateCreated datePublished" datetime="2022-08-15T08:14:16+08:00">2022-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-23 17:30:55" itemprop="dateModified" datetime="2023-02-23T17:30:55+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-安装protocbuf"><a href="#1-安装protocbuf" class="headerlink" title="1.安装protocbuf"></a>1.安装protocbuf</h2><ol>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/protocolbuffers/protobuf/releases/tag/v3.19.1">下载protobuf</a> window版</p>
</li>
<li><p>配置环境变量：</p>
</li>
</ol>
<p><code>变量名</code>：PROTOCBUF_HOME</p>
<p><code>变量值</code>：D:\protoc-3.19.1-win64</p>
<p>找到系统变量中的<code>path</code>变量，选中后点击<code>编辑</code>，在<code>新建</code>的内容中输入：%PROTOBUF_HOME%\bin</p>
<ol start="3">
<li>idea安装protocbuf插件</li>
</ol>
<h2 id="2-gRPC项目构建"><a href="#2-gRPC项目构建" class="headerlink" title="2. gRPC项目构建"></a>2. gRPC项目构建</h2><h3 id="1-插件"><a href="#1-插件" class="headerlink" title="1. 插件"></a>1. 插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;extensions&gt;</span><br><span class="line">    &lt;extension&gt;</span><br><span class="line">      &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.6.2&lt;/version&gt;</span><br><span class="line">    &lt;/extension&gt;</span><br><span class="line">  &lt;/extensions&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.6.1&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;protocArtifact&gt;com.google.protobuf:protoc:3.17.3:exe:$&#123;os.detected.classifier&#125;&lt;/protocArtifact&gt;</span><br><span class="line">        &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;</span><br><span class="line">        &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.42.0:exe:$&#123;os.detected.classifier&#125;&lt;/pluginArtifact&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">            &lt;goal&gt;compile-custom&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-netty-shaded&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.42.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-protobuf&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.42.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-stub&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.42.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt; &lt;!-- necessary for Java 9+ --&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;annotations-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;6.0.53&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-添加-proto文件"><a href="#2-添加-proto文件" class="headerlink" title="2. 添加.proto文件"></a>2. 添加.proto文件</h3><p>  一定要在和src&#x2F;main&#x2F;java源文件目录同级的proto源文件目录才可以。 </p>
<p>helloworld.proto</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; // 协议版本</span><br><span class="line"></span><br><span class="line">// 选项配置</span><br><span class="line">option java_package = &quot;com.cgh.protobuf&quot;;</span><br><span class="line">option java_outer_classname = &quot;RPCDateServiceApi&quot;;</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line"></span><br><span class="line">// 定义包名</span><br><span class="line">package com.cgh.protobuf;</span><br><span class="line"></span><br><span class="line">// 服务接口.定义请求参数和相应结果</span><br><span class="line">service RPCDateService &#123;</span><br><span class="line">  rpc getDate (RPCDateRequest) returns (RPCDateResponse) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义请求体</span><br><span class="line">message RPCDateRequest &#123;</span><br><span class="line">  string userName = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义响应内容</span><br><span class="line">message RPCDateResponse &#123;</span><br><span class="line">  string serverDate = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-用插件根据-proto文件生成消息体类文件和XXXGrpc类文件"><a href="#3-用插件根据-proto文件生成消息体类文件和XXXGrpc类文件" class="headerlink" title="3. 用插件根据.proto文件生成消息体类文件和XXXGrpc类文件"></a>3. 用插件根据.proto文件生成消息体类文件和XXXGrpc类文件</h3><ul>
<li><code>mvn protobuf:compile</code> 生成消息体类文件  （多次执行可能失败）</li>
<li><code>mvn protobuf:compile-custom</code> 生成XXXGrpc类文件  （多次执行可能失败)</li>
<li>把生成的消息体文件和 XXXGrpc 文件copy到项目</li>
</ul>
<h3 id="4-编写实现类"><a href="#4-编写实现类" class="headerlink" title="4. 编写实现类"></a>4. 编写实现类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import com.cgh.protobuf.RPCDateRequest;</span><br><span class="line">import com.cgh.protobuf.RPCDateResponse;</span><br><span class="line">import com.cgh.protobuf.RPCDateServiceGrpc;</span><br><span class="line">import io.grpc.stub.StreamObserver;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line">public class RPCDateServiceImpl extends RPCDateServiceGrpc.RPCDateServiceImplBase &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getDate(RPCDateRequest request, StreamObserver&lt;RPCDateResponse&gt; responseObserver) &#123;</span><br><span class="line">        //请求结果，我们定义的</span><br><span class="line">        RPCDateResponse rpcDateResponse = null;</span><br><span class="line">        //</span><br><span class="line">        String userName = request.getUserName();</span><br><span class="line">        String response = String.format(&quot;你好:%s,今天是%s.&quot;, userName, LocalDate.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;)));</span><br><span class="line">        try &#123;</span><br><span class="line">            // 定义响应,是一个builder构造器.</span><br><span class="line">            rpcDateResponse = RPCDateResponse.newBuilder()</span><br><span class="line">                    .setServerDate(response)</span><br><span class="line">                    .build();</span><br><span class="line">            //int i = 10/0;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            responseObserver.onError(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">            responseObserver.onNext(rpcDateResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-定义服务端"><a href="#5-定义服务端" class="headerlink" title="5. 定义服务端"></a>5. 定义服务端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GRPCServer &#123;</span><br><span class="line">    private static final int port = 9999;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">        //设置service端口</span><br><span class="line">        Server server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService(new RPCDateServiceImpl())</span><br><span class="line">                .build().start();</span><br><span class="line">        System.out.println(String.format(&quot;GRpc服务端启动成功, 端口号: %d.&quot;, port));</span><br><span class="line"></span><br><span class="line">        server.awaitTermination();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-定义客户端"><a href="#6-定义客户端" class="headerlink" title="6. 定义客户端"></a>6. 定义客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static final String host = &quot;localhost&quot;;</span><br><span class="line">    private static final int serverPort = 9999;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1,拿到一个通信channel</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(host, serverPort).</span><br><span class="line">                usePlaintext()//无需加密或认证</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            //2.拿到stub对象</span><br><span class="line">            RPCDateServiceGrpc.RPCDateServiceBlockingStub rpcDateService  = RPCDateServiceGrpc.newBlockingStub(channel);</span><br><span class="line">            RPCDateRequest rpcDateRequest = RPCDateRequest.newBuilder()</span><br><span class="line">                    .setUserName(&quot;JACK&quot;)</span><br><span class="line">                    .build();</span><br><span class="line">            //3,请求</span><br><span class="line">            RPCDateResponse rpcDateResponse = rpcDateService.getDate(rpcDateRequest);</span><br><span class="line">            //4,输出结果</span><br><span class="line">            System.out.println(rpcDateResponse.getServerDate());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 5.关闭channel, 释放资源.</span><br><span class="line">            channel.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2022/08/15/es/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/es/" class="post-title-link" itemprop="url">es</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-15 08:14:16" itemprop="dateCreated datePublished" datetime="2022-08-15T08:14:16+08:00">2022-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-23 17:28:42" itemprop="dateModified" datetime="2023-02-23T17:28:42+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-十亿级数据ES搜索怎么优化"><a href="#1-十亿级数据ES搜索怎么优化" class="headerlink" title="1. 十亿级数据ES搜索怎么优化?"></a>1. 十亿级数据ES搜索怎么优化?</h2><blockquote>
<p>es 的搜索引擎严重依赖于底层的 <code>filesystem cache</code>，你如果给 <code>filesystem cache</code> 更多的内存，尽量让内存可以容纳所有的 <code>idx segment file</code> 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高</p>
</blockquote>
<ul>
<li>存尽量少字段  ，可以采用<code>es</code>+<code>hbase</code></li>
<li>数据预热，程序定时刷新数据到 <code>filesystem cache</code></li>
<li>冷热分离 ， 冷热数据单独建立索引，避免冷数据刷掉热数据的<code>filesystem cache</code></li>
<li>直接写入计算好数据，避免join操作</li>
<li>分页性能优化</li>
</ul>
<p>​    es 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p>
<h2 id="2-在数据量很大的情况下，怎么实现深度分页？"><a href="#2-在数据量很大的情况下，怎么实现深度分页？" class="headerlink" title="2. 在数据量很大的情况下，怎么实现深度分页？"></a>2. 在数据量很大的情况下，怎么实现深度分页？</h2><h2 id="3-es-读写数据过程-和检索过程"><a href="#3-es-读写数据过程-和检索过程" class="headerlink" title="3. es 读写数据过程 和检索过程"></a>3. es 读写数据过程 和检索过程</h2><h3 id="1-写"><a href="#1-写" class="headerlink" title="1. 写"></a>1. 写</h3><ul>
<li>客户端选择一个 node 发送请求过去，这个 node 就是 <code>coordinating node</code>（协调节点）。</li>
<li><code>coordinating node</code> 对 document 进行路由，将请求转发给对应的 node（有 primary shard）。</li>
<li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到 <code>replica node</code>。</li>
<li><code>coordinating node</code> 如果发现 <code>primary node</code> 和所有 <code>replica node</code> 都搞定之后，就返回响应结果给客户端。</li>
</ul>
<h3 id="2-读"><a href="#2-读" class="headerlink" title="2. 读"></a>2. 读</h3><p>可以通过 <code>doc id</code> 来查询，会根据 <code>doc id</code> 进行 hash，判断出来当时把 <code>doc id</code> 分配到了哪个 shard 上面去，从那个 shard 去查询。</p>
<ul>
<li>客户端发送请求到任意一个 node，成为 <code>coordinate node</code>。</li>
<li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code>随机轮询算法，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li>
<li>接收请求的 node 返回 document 给 <code>coordinate node</code>。</li>
<li><code>coordinate node</code> 返回 document 给客户端。</li>
</ul>
<h3 id="3-检索"><a href="#3-检索" class="headerlink" title="3.检索"></a>3.检索</h3><p>客户端发送请求到一个 <code>coordinate node</code>。</p>
<p>协调节点将搜索请求转发到所有的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code>，都可以。</p>
<p>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code>）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</p>
<p>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上拉取实际的 <code>document</code> 数据，最终返回给客户端。</p>
<p>​     </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2022/08/15/fastjson/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/fastjson/" class="post-title-link" itemprop="url">JSON使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-15 08:14:16" itemprop="dateCreated datePublished" datetime="2022-08-15T08:14:16+08:00">2022-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-23 17:29:33" itemprop="dateModified" datetime="2023-02-23T17:29:33+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>泛型反序列化</li>
</ol>
<p>​        <code>new TypeReference&lt;List&lt;User&gt;&gt;()</code></p>
<ol start="2">
<li><p>如果数据对象中存在Map对象，为了保证序列化后的字段顺序一致，需要添加<code>SerializerFeature.MapSortField</code>特征。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.toJSONString(userMap, SerializerFeature.MapSortField);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>排除所有类的属性字段：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserVO&gt; userList = ...;SimplePropertyPreFilter filter = new SimplePropertyPreFilter();filter.getExcludes().addAll(Arrays.asList(&quot;gmtCreate&quot;, &quot;gmtModified&quot;));Assert.assertEquals(&quot;用户信息不一致&quot;, text, JSON.toJSONString(user, filter));</span><br></pre></td></tr></table></figure>

<p><strong>排除单个类的属性字段：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserVO&gt; userList = ...;SimplePropertyPreFilter filter = new SimplePropertyPreFilter(UserVO.class);filter.getExcludes().addAll(Arrays.asList(&quot;gmtCreate&quot;, &quot;gmtModified&quot;));Assert.assertEquals(&quot;用户信息不一致&quot;, text, JSON.toJSONString(user, filter));</span><br></pre></td></tr></table></figure>

<p><strong>排查多个类属性：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;UserVO, CompanyVO&gt; userCompanyPair = ...;</span><br><span class="line"><span class="type">SimplePropertyPreFilter</span> <span class="variable">userFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimplePropertyPreFilter</span>(UserVO.class);</span><br><span class="line">userFilter.getExcludes().addAll(Arrays.asList(<span class="string">&quot;gmtCreate&quot;</span>, <span class="string">&quot;gmtModified&quot;</span>));</span><br><span class="line"><span class="type">SimplePropertyPreFilter</span> <span class="variable">companyFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimplePropertyPreFilter</span>(CompanyVO.class);</span><br><span class="line">companyFilter.getExcludes().addAll(Arrays.asList(<span class="string">&quot;createTime&quot;</span>, <span class="string">&quot;modifyTime&quot;</span>));</span><br><span class="line">Assert.assertEquals(<span class="string">&quot;用户公司对不一致&quot;</span>, text, JSON.toJSONString(userCompanyPair, <span class="keyword">new</span> <span class="title class_">SerializeFilter</span>[]&#123;userFilter, companyFilter&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2022/08/15/forkJoin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/forkJoin/" class="post-title-link" itemprop="url">forkjion原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-15 08:14:16" itemprop="dateCreated datePublished" datetime="2022-08-15T08:14:16+08:00">2022-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-23 17:30:22" itemprop="dateModified" datetime="2023-02-23T17:30:22+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><code>forkJoin</code> 把大任务拆分成小任务，放到不同的队列中，每个队列对应一个线程进行处理</p>
</blockquote>
<p><code>forkJoinTask</code> 三个实现类：</p>
<ul>
<li><p>RecursiveAction</p>
<p>无结果返回的任务</p>
</li>
<li><p>RecursiveTask</p>
<p>有返回结果的任务</p>
</li>
<li><p>CountedCompleter</p>
<p>无返回值任务，完成任务后可以触发回调</p>
</li>
</ul>
<h2 id="工作窃取（-work-stealing-）算法"><a href="#工作窃取（-work-stealing-）算法" class="headerlink" title="工作窃取（ work-stealing ）算法"></a>工作窃取（ work-stealing ）算法</h2><blockquote>
<p>闲的线程试图从繁忙线程的 <code>deques</code> 中 窃取工作</p>
</blockquote>
<p>默认情况下，每个工作线程从其自己的双端队列中获取任务。但如果自己的双端队列中的任务已经执行完毕，双端队列为空时，工作线程就会从另一个忙线程的双端队列尾部或全局入口队列中获取任务，因为这是最大概率可能找到工作的地方</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2022/08/15/feign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/feign/" class="post-title-link" itemprop="url">feign使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-15 08:14:16" itemprop="dateCreated datePublished" datetime="2022-08-15T08:14:16+08:00">2022-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-23 17:29:43" itemprop="dateModified" datetime="2023-02-23T17:29:43+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-feign-日志"><a href="#1-feign-日志" class="headerlink" title="1. feign 日志"></a>1. feign 日志</h2><h3 id="1-配置方式"><a href="#1-配置方式" class="headerlink" title="1. 配置方式"></a>1. 配置方式</h3><ol>
<li>基于配置文件修改feign的日志级别可以针对单个服务</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign:  </span><br><span class="line">  client:</span><br><span class="line">    config: </span><br><span class="line">      userservice: # 针对某个微服务的配置</span><br><span class="line">        loggerLevel: FULL #  日志级别 </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>针对所有服务</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign:  </span><br><span class="line">  client:</span><br><span class="line">    config: </span><br><span class="line">      default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span><br><span class="line">        loggerLevel: FULL #  日志级别 </span><br></pre></td></tr></table></figure>

<h3 id="2-java-代码方式"><a href="#2-java-代码方式" class="headerlink" title="2. java 代码方式"></a>2. <code>java</code> 代码方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultFeignConfiguration  &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Logger.Level feignLogLevel()&#123;</span><br><span class="line">        return Logger.Level.BASIC; // 日志级别为BASIC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>全局</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration.class)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>局部</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span><br></pre></td></tr></table></figure>

<h2 id="3-支持httpClient"><a href="#3-支持httpClient" class="headerlink" title="3. 支持httpClient"></a>3. 支持<code>httpClient</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--httpClient的依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      default: # default全局的配置</span><br><span class="line">        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息</span><br><span class="line">  httpclient:</span><br><span class="line">    enabled: true # 开启feign对HttpClient的支持</span><br><span class="line">    max-connections: 200 # 最大的连接数</span><br><span class="line">    max-connections-per-route: 50 # 每个路径的最大连接数</span><br></pre></td></tr></table></figure>

<h2 id="4-FeignClient整合Sentinel"><a href="#4-FeignClient整合Sentinel" class="headerlink" title="4. FeignClient整合Sentinel"></a>4. <code>FeignClient</code>整合Sentinel</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: true # 开启feign对sentinel的支持</span><br></pre></td></tr></table></figure>

<h2 id="5-feign-降级"><a href="#5-feign-降级" class="headerlink" title="5. feign 降级"></a>5. feign 降级</h2><ul>
<li><code>FallbackClass</code>无法对远程调用的异常做处理</li>
<li><code>FallbackFactory</code>，可以对远程调用的异常做处理</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2022/08/15/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/mysql/" class="post-title-link" itemprop="url">mysql相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-15 08:14:16" itemprop="dateCreated datePublished" datetime="2022-08-15T08:14:16+08:00">2022-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-23 17:38:09" itemprop="dateModified" datetime="2023-02-23T17:38:09+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-MVVC"><a href="#1-MVVC" class="headerlink" title="1. MVVC"></a>1. MVVC</h2><blockquote>
<p>MVCC用于读已提交和可重复读级别的控制，主要通过undo log日志版本链和read view来实现</p>
</blockquote>
<p>每个字段隐藏两个字段： roll_pointer<code>和</code>trx_id</p>
<p>roll_pointer指向更新事务之前生成的undo log，undo log用于事务的回滚，保证事务的原子性。</p>
<p>trx_id就是最近一次更新数据的事务ID</p>
<p><strong>ReadView 重要概念：</strong></p>
<ol>
<li>m_ids，就是还未提交的事务id集合</li>
<li>low_limit_id，ReadView 生成时刻系统尚未分配的下一个事务 ID</li>
<li>up_limit_id，<strong>是 trx_list 列表中事务 ID 最小的 ID</strong></li>
<li>creator_trx_id，创建read view的事务ID，也就是自己的事务</li>
</ol>
<p><strong>ReadView原理：</strong></p>
<ol>
<li>如果trx_id&lt;up_limit_id，那么说明就是之前事务的数据，直接返回，也就对应了小明第一次开启事务查询的场景</li>
<li>如果trx_id&gt;low_limit_id，trx_id还在[up_limit_id，low_limit_id]范围之内，并且trx_id在m_ids中，就会根据roll_pointer去查找undo log日志链，找到之前版本的数据。</li>
<li>如果trx_id&#x3D;creator_trx_id，那么说明就是自己修改的，直接返回就好了，对应的就是自己去修改数据的场景</li>
</ol>
<p><strong>不同隔离级别创建ReadView</strong> </p>
<ol>
<li>读提交</li>
</ol>
<p>​       每次查询都会生成一次read view</p>
<ol>
<li>可重复读</li>
</ol>
<p>​       整个事务生成一次快照读，并且在第一次读取时</p>
<h2 id="2-mysql-事务"><a href="#2-mysql-事务" class="headerlink" title="2. mysql 事务"></a>2. mysql 事务</h2><ul>
<li>原子性 ： 要么都成功，要么都失败</li>
<li>一致性 ： 从一个状态转换另一个稳定状态</li>
<li>隔离性 : 事务之间互补影响</li>
<li>持久性 :  事务一旦提交就永久有效</li>
</ul>
<h3 id="2-1-事务实现"><a href="#2-1-事务实现" class="headerlink" title="2.1 事务实现"></a>2.1 事务实现</h3><p><img src="/.%5Cmysql%5Cmysql%E4%BA%8B%E5%8A%A1.svg" alt="mysql事务"></p>
<p>redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p>
<h4 id="2-1-1-redo-log-重做日志"><a href="#2-1-1-redo-log-重做日志" class="headerlink" title="2.1.1 redo log 重做日志"></a>2.1.1 redo log 重做日志</h4><p>redo log 有两部分组成 redo log buffer ，redo log  file</p>
<p>redo log 写入流程：</p>
<ul>
<li><p>执行update操作。</p>
</li>
<li><p>先将原始数据从磁盘读取到内存，修改内存中的数据。</p>
</li>
<li><p>生成一条重做日志写入redo log buffer，记录数据被修改后的值。</p>
</li>
<li><p>当事务提交时，需要将redo log buffer中的内容刷新到redo log file。</p>
</li>
<li><p>事务提交后，也会将内存中修改数据的值写入磁盘。</p>
</li>
</ul>
<p><strong>redo log为什么可以实现事务的原子性和持久性？</strong></p>
<ul>
<li><p>原子性，是redo log记录了事务期间操作的物理日志，事务提交之前，并没有写入磁盘，保存在内存里，如果事务失败，数据库磁盘不会有影响，回滚掉事务内存部分即可。</p>
</li>
<li><p>持久性，redo log 会在事务提交时将日志存储到磁盘redo log file，保证日志的持久性。</p>
</li>
</ul>
<h3 id="2-1-2-事务隔离级别"><a href="#2-1-2-事务隔离级别" class="headerlink" title="2.1.2  事务隔离级别"></a>2.1.2  事务隔离级别</h3><p>READ-UNCOMMITTED: 读未提交</p>
<p>READ-COMMITTED：读以提交</p>
<p>REPEATABLE-READ：可重复读</p>
<p>SERIALIZABLE: 序列化</p>
<h2 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3. 执行流程"></a>3. 执行流程</h2><ol>
<li>客户端发送更新命令到MySQL服务器，经过处理连接、解析优化等步骤；</li>
<li>Server层向InnoDB存储引擎要id&#x3D;1的这条记录；</li>
<li>存储引擎先从缓存中查找这条记录，有的话直接返回，没有则从磁盘加载到缓存中然后返回；</li>
<li>Server层执行器修改这条记录的name字段值；</li>
<li>存储引擎更新修改到内存中；</li>
<li>存储引擎记录redo日志，并将状态设置为<code>prepare</code>状态；</li>
<li>存储引擎通知执行器，修改完毕，可以进行事务提交；</li>
<li>Server先写了个binlog；</li>
<li>Server提交事务；</li>
<li>存储引擎将redo日志中和当前事务相关的记录状态设置为<code>commit</code>状态。</li>
</ol>
<h2 id="4-调优"><a href="#4-调优" class="headerlink" title="4. 调优"></a>4. 调优</h2><h3 id="4-1-工具-Explain使用"><a href="#4-1-工具-Explain使用" class="headerlink" title="4.1 工具 Explain使用"></a>4.1 工具 Explain使用</h3><p>select： all-&gt;index-&gt;rang-&gt;ref-&gt;const   查询速度递增</p>
<h3 id="4-2-mysql-优化原则"><a href="#4-2-mysql-优化原则" class="headerlink" title="4.2 mysql 优化原则"></a>4.2 mysql 优化原则</h3><ul>
<li>最左匹配</li>
<li>避免回表，（覆盖索引）</li>
<li>索引下推 5.6</li>
<li>不为离散度低数据设置索引 如sex</li>
<li>随机无序的值不作为索引，如身份证号，UUID</li>
<li>为用于搜索，排序，分组字段建立索引</li>
<li>频繁更新字段不适合作为索引</li>
</ul>
<h3 id="4-3-大表如何删除数据"><a href="#4-3-大表如何删除数据" class="headerlink" title="4.3 大表如何删除数据"></a>4.3 大表如何删除数据</h3><ul>
<li>删除索引</li>
<li>删除数据</li>
<li>创建索引</li>
</ul>
<h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5.使用"></a>5.使用</h2><p><strong>create</strong> <strong>user</strong> ‘ua‘@’%’ identified <strong>by</strong> ‘pa’; 创建用户（ua）和密码（pa）</p>
<p><strong>grant</strong> <strong>all</strong> privileges <strong>on</strong> <em>.</em> <strong>to</strong> ‘ua‘@’%’ <strong>with</strong> <strong>grant</strong> option; 全局权限</p>
<blockquote>
<p>注意： 对于一个已经存在的连接，它的全局权限不受 grant 命令的影响</p>
</blockquote>
<p><strong>revoke</strong> <strong>all</strong> privileges <strong>on</strong> <em>.</em> <strong>from</strong> ‘ua‘@’%’; 收回权限</p>
<h3 id="5-1-Db权限"><a href="#5-1-Db权限" class="headerlink" title="5.1 Db权限"></a>5.1 Db权限</h3><p><strong>grant</strong> <strong>all</strong> privileges <strong>on</strong> db1.* <strong>to</strong> ‘ua‘@’%’ <strong>with</strong> <strong>grant</strong> option;</p>
<blockquote>
<p>grant 修改 db 权限的时候，是同时对磁盘和内存生效的</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2022/08/15/rocket%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/rocket%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/" class="post-title-link" itemprop="url">rocketMq事务消息实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-15 08:14:16" itemprop="dateCreated datePublished" datetime="2022-08-15T08:14:16+08:00">2022-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-23 17:39:30" itemprop="dateModified" datetime="2023-02-23T17:39:30+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1.流程"></a>1.流程</h3><p>RocketMQ 4.3 开始支持事务</p>
<p><strong>(1)、正常事务消息的发送及提交</strong><br>a、生产者发送half消息到Broker服务端（半消息）；</p>
<p>半消息是一种特殊的消息类型，该状态的消息暂时不能被Consumer消费。当一条事务消息被成功投递到Broker上，但是Broker并没有接收到Producer发出的二次确认时，该事务消息就处于”暂时不可被消费”状态，该状态的事务消息被称为半消息。</p>
<p>b、Broker服务端将消息持久化之后，给生产者响应消息写入结果（ACK响应）；</p>
<p>c、生产者根据发送结果执行本地事务逻辑（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）；</p>
<p>d、生产者根据本地事务执行结果向Broker服务端提交二次确认（Commit 或是 Rollback），Broker服务端收到 Commit 状态则将半事务消息标记为可投递，订阅方最终将收到该消息；Broker服务端收到 Rollback 状态则删除半事务消息，订阅方将不会接收该消息；</p>
<p><strong>(2)、事务消息的补偿流程</strong><br>a、在网络闪断或者是应用重启的情况下，可能导致生产者发送的二次确认消息未能到达Broker服务端，经过固定时间后，Broker服务端将会对没有Commit&#x2F;Rollback的事务消息（pending状态的消息）进行“回查”；</p>
<p>b、生产者收到回查消息后，检查回查消息对应的本地事务执行的最终结果；</p>
<p>c、生产者根据本地事务状态，再次提交二次确认给Broker，然后Broker重新对半事务消息Commit或者Rollback；</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>
<ul>
<li><p>TransactionStatus.CommitTransaction：提交事务，它允许消费者消费此消息。</p>
</li>
<li><p>TransactionStatus.RollbackTransaction：回滚事务，它代表该消息将被删除，不允许被消费</p>
</li>
</ul>
<ul>
<li>TransactionStatus.Unknown：中间状态，它代表需要回查本地事务状态来决定是提交还是回滚事务。</li>
</ul>
<h3 id="2-事例"><a href="#2-事例" class="headerlink" title="2.事例"></a>2.事例</h3><h4 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h4><p>使用 <code>TransactionMQProducer</code>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">mport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line">import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line">import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line">import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line">import org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line">import java.util.List;</span><br><span class="line">public class TransactionProducer &#123;</span><br><span class="line">   public static void main(String[] args) throws MQClientException, InterruptedException &#123;</span><br><span class="line">       TransactionListener transactionListener = new TransactionListenerImpl();</span><br><span class="line">       TransactionMQProducer producer = new TransactionMQProducer(&quot;please_rename_unique_group_name&quot;);</span><br><span class="line">       ExecutorService executorService = new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2000), new ThreadFactory() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public Thread newThread(Runnable r) &#123;</span><br><span class="line">               Thread thread = new Thread(r);</span><br><span class="line">               thread.setName(&quot;client-transaction-msg-check-thread&quot;);</span><br><span class="line">               return thread;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       producer.setExecutorService(executorService);</span><br><span class="line">       producer.setTransactionListener(transactionListener);</span><br><span class="line">       producer.start();</span><br><span class="line">       String[] tags = new String[] &#123;&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;&#125;;</span><br><span class="line">       for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               Message msg =</span><br><span class="line">                   new Message(&quot;TopicTest1234&quot;, tags[i % tags.length], &quot;KEY&quot; + i,</span><br><span class="line">                       (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">               SendResult sendResult = producer.sendMessageInTransaction(msg, null);</span><br><span class="line">               System.out.printf(&quot;%s%n&quot;, sendResult);</span><br><span class="line">               Thread.sleep(10);</span><br><span class="line">           &#125; catch (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">           Thread.sleep(1000);</span><br><span class="line">       &#125;</span><br><span class="line">       producer.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现事务的监听接口"><a href="#实现事务的监听接口" class="headerlink" title="实现事务的监听接口"></a>实现事务的监听接口</h4><p>当发送半消息成功时，我们使用 <code>executeLocalTransaction</code> 方法来执行本地事务。它返回前一节中提到的三个事务状态之一。<code>checkLocalTransaction</code> 方法用于检查本地事务状态，并回应消息队列的检查请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionListenerImpl implements TransactionListener &#123;</span><br><span class="line">  private AtomicInteger transactionIndex = new AtomicInteger(0);</span><br><span class="line">  private ConcurrentHashMap&lt;String, Integer&gt; localTrans = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  /***</span><br><span class="line">  *** 执行成功half消息，执行本地事务</span><br><span class="line">  ****/</span><br><span class="line">  @Override</span><br><span class="line">  public LocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">      int value = transactionIndex.getAndIncrement();</span><br><span class="line">      int status = value % 3;</span><br><span class="line">      localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">      return LocalTransactionState.UNKNOW;</span><br><span class="line">  &#125;</span><br><span class="line">  /****</span><br><span class="line">  **** 会查本地消息状态</span><br><span class="line">  ****/</span><br><span class="line">  @Override</span><br><span class="line">  public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123;</span><br><span class="line">      Integer status = localTrans.get(msg.getTransactionId());</span><br><span class="line">      if (null != status) &#123;</span><br><span class="line">          switch (status) &#123;</span><br><span class="line">              case 0:</span><br><span class="line">                  return LocalTransactionState.UNKNOW;</span><br><span class="line">              case 1:</span><br><span class="line">                  return LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">              case 2:</span><br><span class="line">                  return LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h3><p>​     在RocketMQ事务消息的主要流程中，一阶段的消息如何对用户不可见。其中，事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的。那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后改变主题为<code>RMQ_SYS_TRANS_HALF_TOPIC</code>。由于消费组未订阅该主题，故消费端无法消费half类型的消息。</p>
<ul>
<li>如何实现事务回查？</li>
</ul>
<p>​       roker会启动一个消息回查的定时任务，定时从事务消息queue中读取所有待反查的消息。针对每个需要反查的半消息，Broker会给对应的Producer发一个要求执行事务状态反查的RPC请求。然后根据RPC返回响应中的反查结果，来决定这个半消息是需要提交还是回滚，或者后续继续来反查。最后，提交或者回滚事务，将半消息标记为已处理状态【将消息存储在主题为：RMQ_SYS_TRANS_OP_HALF_TOPIC的主题中，代表这些消息已经被处理（提交或回滚）】。 如果是提交事务，就把半消息从半消息队列中复制到该消息真正的topic和queue中； 如果是回滚事务，则什么都不做。</p>
<h3 id="4-事务消息使用上的限制"><a href="#4-事务消息使用上的限制" class="headerlink" title="4. 事务消息使用上的限制"></a>4. 事务消息使用上的限制</h3><ol>
<li>事务消息不支持延时消息和批量消息。</li>
<li>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N &#x3D; <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionalMessageCheckListener</code> 类来修改这个行为。</li>
<li>事务消息将在 Broker 配置文件中的参数 transactionTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionTimeout</code> 参数。</li>
<li>事务性消息可能不止一次被检查或消费。</li>
<li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</li>
<li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</li>
</ol>
<p>参考 ： <a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#1%E5%88%9B%E5%BB%BA%E4%BA%8B%E5%8A%A1%E6%80%A7%E7%94%9F%E4%BA%A7%E8%80%85">rocket官方连接</a><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#1%E5%88%9B%E5%BB%BA%E4%BA%8B%E5%8A%A1%E6%80%A7%E7%94%9F%E4%BA%A7%E8%80%85">https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#1%E5%88%9B%E5%BB%BA%E4%BA%8B%E5%8A%A1%E6%80%A7%E7%94%9F%E4%BA%A7%E8%80%85</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenguanghua.github.io/2022/08/15/spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="热心的蚂蚁">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 热心的蚂蚁的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/spring/" class="post-title-link" itemprop="url">spring为题总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-15 08:14:16" itemprop="dateCreated datePublished" datetime="2022-08-15T08:14:16+08:00">2022-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-23 17:40:01" itemprop="dateModified" datetime="2023-02-23T17:40:01+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-谈一谈spring-ioc理解？原理和实现"><a href="#1-谈一谈spring-ioc理解？原理和实现" class="headerlink" title="1. 谈一谈spring ioc理解？原理和实现"></a>1. 谈一谈spring ioc理解？原理和实现</h2><p>IOC ：控制反转， 对象一般都使用者创建，有了spring后把对象创建交给spring 容器.即</p>
<p>容器来负责控制对象的生命周期和对象间的关系</p>
<p>容器：存储对象，三级缓存 sigletionObjects ,earingsigletionObject ,sigletionFacotry</p>
<h2 id="2-bean的生命周期"><a href="#2-bean的生命周期" class="headerlink" title="2.bean的生命周期"></a>2.bean的生命周期</h2><blockquote>
<p> 创建实例-&gt;填充属性-&gt;初始化-&gt;使用-&gt;销毁</p>
</blockquote>
<ul>
<li>加载解析bean为beanDefinition</li>
<li>通过反射实例化具体对象 </li>
<li>填充属性 ： populateBean(),循环依赖</li>
<li>调用aware方法： 设置 BeanName ,BeanFactory </li>
<li>初始化 调用BeanPostProcessor</li>
</ul>
<p><img src="/.%5C%E5%9B%BE%E7%89%87%5Cspring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="spring生命周期"></p>
<h2 id="3-Spring是如何解决的循环依赖？"><a href="#3-Spring是如何解决的循环依赖？" class="headerlink" title="3.Spring是如何解决的循环依赖？"></a>3.Spring是如何解决的循环依赖？</h2><p>   Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（singletonObjects）,二级缓存为早期曝光对象earlySingletonObjects，三级缓存为早期曝光对象工厂（singletonFactories）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p>
<h2 id="4-为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？"><a href="#4-为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？" class="headerlink" title="4.为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？"></a>4.为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？</h2><p>​    如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">热心的蚂蚁</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

-->
    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
