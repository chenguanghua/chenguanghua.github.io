<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>零拷贝</title>
      <link href="/2023/08/15/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
      <url>/2023/08/15/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是零拷贝"><a href="#1-什么是零拷贝" class="headerlink" title="1.什么是零拷贝"></a>1.什么是零拷贝</h2><blockquote><p>零拷贝是指计算机在执行IO操作的时候, CPU不需要将数据从一个存储区复制到另一个存储区, 进而减少上下文切换以及 CPU 拷贝的时间, 这是一种<code>IO操作优化技术</code></p><p>零拷贝不是没有拷贝数据, 而是<code>减少用户态, 内核态的切换次数 和 CPU拷贝次数</code></p></blockquote><h2 id="2-传统IO"><a href="#2-传统IO" class="headerlink" title="2. 传统IO"></a>2. 传统IO</h2><p><img src="/../images/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9Fio.png" alt="1"></p><h2 id="3-实现方式"><a href="#3-实现方式" class="headerlink" title="3. 实现方式"></a>3. 实现方式</h2><h3 id="3-1-mmap-write"><a href="#3-1-mmap-write" class="headerlink" title="3.1.mmap + write"></a>3.1.<code>mmap + write</code></h3><blockquote><p> 虚拟内存把内核空间和用户空间的虚拟地址映射到同一个物理地址, 从而减少数据拷贝次数, <code>mmap</code>技术就是利用了虚拟内存的这个特点, 它将内核中的读缓冲区与用户空间的缓冲区进行映射, 所有的IO操作都在内核中完成</p></blockquote><p><img src="/../images/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap+write.png" alt="1"></p><ol><li><p>用户进程通过<code>mmap </code>方法向操作系统内核发起 IO 调用，上下文从用户态切换为内核态。</p></li><li><p>CPU 利用<code>DMA </code>控制器，把数据从硬盘中拷贝到内核缓冲区。</p></li><li><p>上下文从内核态切换回用户态，<code>mmap</code> 方法返回。</p></li><li><p>用户进程通过write 方法向操作系统内核发起IO 调用，上下文从用户态切换为内核态。</p></li><li><p>CPU 将内核缓冲区的数据拷贝到的 socket 缓冲区。</p></li><li><p>CPU 利用<code>DMA</code> 控制器，把数据从 socket 缓冲区拷贝到网卡，上下文从内核态切换回用户态，write 调用返回。</p></li></ol><p><code>mmap+write</code> 实现的零拷贝，I&#x2F;O 发生了4次用户空间与内核空间的上下文切<br>换，以及3 次数据拷贝（包括了2次<code>DMA</code>拷贝和1 次CPU 拷贝）。</p><h3 id="3-2-sendfile"><a href="#3-2-sendfile" class="headerlink" title="3.2 sendfile"></a>3.2 <code>sendfile</code></h3><blockquote><p> <code>sendfile</code> 表示在两个文件描述符之间传输数据，它是在操作系统内核中操作的，<br> 避免了数据从内核缓冲区和用户缓冲区之间的拷贝操作</p></blockquote><p><img src="/../images/%E9%9B%B6%E6%8B%B7%E8%B4%9D/sendFile.png" alt="1"></p><ol><li><p>用户进程发起·<code>sendfile</code> 系统调用，上下文（切换 1）从用户态转向内核态</p></li><li><p><code>DMA </code>控制器，把数据从硬盘中拷贝到内核缓冲区。</p></li><li><p><code>CPU</code> 将读缓冲区中数据拷贝到 socket 缓冲区</p></li><li><p><code>DMA</code> 控制器，异步把数据从 socket 缓冲区拷贝到网卡，</p></li><li><p>上下文（切换2）从内核态切换回用户态，<code>sendfile</code> 调用返回。</p></li></ol><p>  2次上下文切换，2次<code>DMA</code>拷贝，一次<code>cpu</code> 拷贝</p><h3 id="3-3-带DMA收集功能sendfile-sendfile-DMA-Scatter-Gather"><a href="#3-3-带DMA收集功能sendfile-sendfile-DMA-Scatter-Gather" class="headerlink" title="3.3 带DMA收集功能sendfile (sendfile+DMA Scatter/Gather)"></a>3.3 带<code>DMA</code>收集功能<code>sendfile</code> (<code>sendfile+DMA Scatter/Gather</code>)</h3><blockquote><p><code>linux 2.4</code>版本之后，对<code>sendfile</code>做了优化升级，引入<code>SG-DMA</code>技术，其实就是对<code>DMA</code>拷贝加入了<code>scatter/gather</code>操作，它可以直接从内核空间缓冲区中将数据读取到网卡。使用这个特点搞零拷贝，即还可以多省去<strong>一次CPU拷贝</strong>。</p></blockquote><p> <img src="/../images/%E9%9B%B6%E6%8B%B7%E8%B4%9D/sg-sendfile.png"></p><ol><li>用户进程发起<code>sendfile</code>系统调用，<strong>上下文（切换1）从用户态转向内核态</strong></li><li><code>DMA</code>控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li>CPU把内核缓冲区中的<strong>文件描述符信息</strong>（包括内核缓冲区的内存地址和偏移量）发送到socket缓冲区</li><li><code>DMA</code>控制器根据文件描述符信息，直接把数据从内核缓冲区拷贝到网卡</li><li><strong>上下文（切换2）从内核态切换回用户态</strong>，<code>sendfile</code>调用返回。</li></ol><p>​         可以发现，<code>sendfile+DMA scatter/gather</code>实现的零拷贝，I&#x2F;O发生了<strong>2</strong>次用户空间与内核空间的上下文切换，以及2次数据拷贝。其中2次数据拷贝都是包**<code>DMA</code>拷贝**。这就是真正的 <strong>零拷贝（Zero-copy)</strong> 技术，全程都没有通过CPU来搬运数据，所有的数据都是通过<code>DMA</code>来进行传输的。</p><h2 id="4-DMA-技术说明"><a href="#4-DMA-技术说明" class="headerlink" title="4. DMA 技术说明"></a>4. <code>DMA</code> 技术说明</h2><blockquote><p><code>DMA</code>，英文全称是<strong>Direct Memory Access</strong>，即直接内存访问。**<code>DMA</code><strong>本质上是一块主板上独立的芯片，允许外设设备和内存存储器之间直接进行IO数据传输，其过程</strong>不需要CPU的参与**。</p></blockquote><p><img src="/../images/%E9%9B%B6%E6%8B%B7%E8%B4%9D/DMA.png" alt="image-20221216101217488"></p><h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5.应用场景"></a>5.应用场景</h2><p><code>RocketMQ</code>和<code>Kafka</code>都使用到了零拷贝的技术。</p><p>对于<code>MQ</code>而言，无非就是生产者发送数据到<code>MQ</code>然后持久化到磁盘，之后消费者从<code>MQ</code>读取数据。</p><p>对于<code>RocketMQ</code>来说这两个步骤使用的是<code>mmap+write</code>，而Kafka则是使用<code>mmap+write</code>持久化数据，发送数据使用<code>sendfile</code></p><h2 id="6-java对零拷贝支持"><a href="#6-java对零拷贝支持" class="headerlink" title="6.java对零拷贝支持"></a>6.<code>java</code>对零拷贝支持</h2><h3 id="6-1-Java-NIO对mmap的支持"><a href="#6-1-Java-NIO对mmap的支持" class="headerlink" title="6.1 Java NIO对mmap的支持"></a>6.1 Java <code>NIO</code>对<code>mmap</code>的支持</h3><p>​       <code> MappedByteBuffer</code></p><h3 id="6-2-Java-NIO对sendfile的支持"><a href="#6-2-Java-NIO对sendfile的支持" class="headerlink" title="6.2 Java NIO对sendfile的支持"></a>6.2 Java <code>NIO</code>对<code>sendfile</code>的支持</h3><p>​<code>FileChannel</code>的<code>transferTo()/transferFrom()</code>，底层就是<code>sendfile()</code> 系统调用函数</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring加载bean方式大全</title>
      <link href="/2023/08/15/%E4%BB%A3%E7%A0%81/spring%20%E5%8A%A0%E8%BD%BDbean%20%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/08/15/%E4%BB%A3%E7%A0%81/spring%20%E5%8A%A0%E8%BD%BDbean%20%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:bean.xml&quot;</span>);</span><br><span class="line">applicationContext.refresh();</span><br><span class="line">User user= applicationContext.getBean(User.class);</span><br></pre></td></tr></table></figure><h2 id="2-properties配置文件声明Bean的方式"><a href="#2-properties配置文件声明Bean的方式" class="headerlink" title="2.properties配置文件声明Bean的方式"></a>2.properties配置文件声明Bean的方式</h2><p> properties：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.(class) = com.sanyou.spring.bean.injection.User</span><br><span class="line">user.username = sanyou</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GenericApplicationContext applicationContext = new GenericApplicationContext();</span><br><span class="line">      //创建一个PropertiesBeanDefinitionReader，可以从properties读取Bean的信息，将读到的Bean信息放到applicationContext中</span><br><span class="line">      PropertiesBeanDefinitionReader propReader = new PropertiesBeanDefinitionReader(applicationContext);</span><br><span class="line">      //创建一个properties文件对应的Resource对象</span><br><span class="line">      Resource classPathResource = new ClassPathResource(&quot;PropertiesBeanInjectionDemo.properties&quot;);</span><br><span class="line">      //加载配置文件</span><br><span class="line">      propReader.loadBeanDefinitions(classPathResource);</span><br><span class="line">      applicationContext.refresh();</span><br><span class="line">      User user = applicationContext.getBean(User.class);</span><br><span class="line">      System.out.println(user);</span><br></pre></td></tr></table></figure><h2 id="3-Import-方式"><a href="#3-Import-方式" class="headerlink" title="3. @Import 方式"></a>3. @Import 方式</h2><ul><li>导入普通bean，</li></ul><ul><li><p>类实现了<code>ImportSelector</code>接口</p></li><li><p>类实现了<code>ImportBeanDefinitionRegistrar</code>接口</p></li></ul><p>使用场景配合 <code>enableXXX</code>注解使用</p><h2 id="4-注册BeanDefinition"><a href="#4-注册BeanDefinition" class="headerlink" title="4.  注册BeanDefinition"></a>4.  注册<code>BeanDefinition</code></h2><p>  以下两种都可以获取<code>beanDefinitionRegister</code></p><ul><li><code>ImportBeanDefinitionRegistrar</code></li><li><code>BeanDefinitionRegistryPostProcessor</code></li></ul><h2 id="5-注册完整bean"><a href="#5-注册完整bean" class="headerlink" title="5. 注册完整bean"></a>5. 注册完整bean</h2><p>拿到 SingletonBeanRegistry 直接注册，如实现 BeanFactoryPostProcessor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class RegisterUserBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;用户名&quot;);</span><br><span class="line">        //将这个User对象注入到Spring容器中</span><br><span class="line">        beanFactory.registerSingleton(&quot;user&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-注入-beanFactory"><a href="#6-注入-beanFactory" class="headerlink" title="6. 注入 beanFactory"></a>6. 注入 beanFactory</h2><h2 id="7-其他扩展点"><a href="#7-其他扩展点" class="headerlink" title="7 其他扩展点"></a>7 其他扩展点</h2><h2 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a><strong>InstantiationAwareBeanPostProcessor</strong></h2><p><strong><code>BeanPostProcess</code>接口只在bean的初始化阶段进行扩展（注入spring上下文前后），而<code>InstantiationAwareBeanPostProcessor</code>接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。</strong></p><p>该类主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：<strong>实例化阶段</strong> 和<strong>初始化阶段</strong> ，下面一起进行说明，按调用顺序为：</p><ul><li><code>postProcessBeforeInstantiation</code>：实例化bean之前，相当于new这个bean之前</li><li><code>postProcessAfterInstantiation</code>：实例化bean之后，相当于new这个bean之后</li><li><code>postProcessPropertyValues</code>：bean已经实例化完成，在属性注入时阶段触发，<code>@Autowired</code>,<code>@Resource</code>等注解原理基于此方法实现</li><li><code>postProcessBeforeInitialization</code>：初始化bean之前，相当于把bean注入spring上下文之前</li><li><code>postProcessAfterInitialization</code>：初始化bean之后，相当于把bean注入spring上下文之后</li></ul><h2 id="ApplicationContextAwareProcessor"><a href="#ApplicationContextAwareProcessor" class="headerlink" title="ApplicationContextAwareProcessor"></a><strong>ApplicationContextAwareProcessor</strong></h2><p><code>EnvironmentAware</code>：用于获取<code>EnviromentAware</code>的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。<br><code>EmbeddedValueResolverAware</code>：用于获取<code>StringValueResolver</code>的一个扩展类， <code>StringValueResolver</code>用于获取基于<code>String</code>类型的properties的变量，一般我们都用<code>@Value</code>的方式去获取，如果实现了这个Aware接口，把<code>StringValueResolver</code>缓存起来，通过这个类去获取<code>String</code>类型的变量，效果是一样的。<br><code>ResourceLoaderAware</code>：用于获取<code>ResourceLoader</code>的一个扩展类，<code>ResourceLoader</code>可以用于获取classpath内所有的资源对象，可以扩展此类来拿到<code>ResourceLoader</code>对象。<br><code>ApplicationEventPublisherAware</code>：用于获取<code>ApplicationEventPublisher</code>的一个扩展类，<code>ApplicationEventPublisher</code>可以用来发布事件，结合<code>ApplicationListener</code>来共同使用，下文在介绍<code>ApplicationListener</code>时会详细提到。这个对象也可以通过spring注入的方式来获得。<br><code>MessageSourceAware</code>：用于获取<code>MessageSource</code>的一个扩展类，<code>MessageSource</code>主要用来做国际化。<br><code>ApplicationContextAware</code>：用来获取<code>ApplicationContext</code>的一个扩展类，<code>ApplicationContext</code>应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时<code>ApplicationContext</code>也实现了<code>BeanFactory</code>，<code>MessageSource</code>，<code>ApplicationEventPublisher</code>等接口，也可以用来做相关接口的事情。</p><h2 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a><strong>CommandLineRunner</strong></h2><p>触发时机为整个项目启动完毕后，自动执行</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2023/02/24/HashMap/"/>
      <url>/2023/02/24/HashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="1、HashMap-的内部数据结构"><a href="#1、HashMap-的内部数据结构" class="headerlink" title="1、HashMap 的内部数据结构"></a>1、HashMap 的内部数据结构</h2><p>目前我用的是 JDK1.8 版本的，内部使用数组 + 链表 &#x2F; 红黑树链表大于8转换成红黑数，红黑树节点小于6退化为链表</p><h2 id="2、HashMap插入数据流程"><a href="#2、HashMap插入数据流程" class="headerlink" title="2、HashMap插入数据流程"></a>2、HashMap插入数据流程</h2><ul><li><p>判断数组是否为空，为空进行初始化;</p></li><li><p>不为空，计算 k 的 hash 值，通过 (n - 1) &amp; hash计算应当存放在数组中的下标 index ;</p></li><li><p>查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；</p></li><li><p>存在数据，说明发生了hash冲突, 继续判断key是否相等，相等，用新的value替换原数据(onlyIfAbsent为false)；</p></li><li><p>如果不相等，判断当前节点类型是不是树型节点，如果是树型节点，创建树型节点插入红黑树中；</p></li><li><p>如果不是树型节点，创建普通Node加入链表中；</p></li><li><p>判断链表长度是否大于 8，并且数组长度大于64, 大于的话链表转换为红黑树（），</p></li><li><p>链表长度大于8，数据组长度小于64，先进行resize()</p></li><li><p>插入完成之后判断当前节点数是否大于阈值，如果大于开始扩容为原数组的二倍<br>注意:</p></li></ul><p>JDK 1.8 引入了红黑树，<strong>当链表的长度大于 8 的时候就会转换为红黑树，不过，在转换之前，会先去查看 table 数组的长度是否大于 64，如果数组的长度小于 64，那么 HashMap 会优先选择对数组进行扩容</strong>  <code>**resize**</code><strong>，而不是把链表转换成红黑树,进行resize时当红黑树节点小于6时，转换成链表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//onlyIfAbsent 是否覆盖key相同值，true 覆盖，默认false</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        //判断链表长度是否大于8 大于8转换成红黑树</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br></pre></td></tr></table></figure><h2 id="2、HashMap获取流程"><a href="#2、HashMap获取流程" class="headerlink" title="2、HashMap获取流程"></a>2、HashMap获取流程</h2><ul><li><p>获取原生key的hash， (n-1)&amp;hash 计算节点存储index</p></li><li><p>获取tab[index] 是否存在，不存在返回null</p></li><li><p>存在比较key值是否相等，相等返回值</p></li><li><p>key值数组首节点不相等，获取首节点next节点，next为空返回null</p></li><li><p>遍历根据类型变量next节点</p></li><li><p>为ListNode则遍历查找</p></li><li><p>为treeNode节点则 当前节点hash是否大于</p></li></ul><h2 id="3、HashMap的哈希函数怎么设计"><a href="#3、HashMap的哈希函数怎么设计" class="headerlink" title="3、HashMap的哈希函数怎么设计"></a>3、HashMap的哈希函数怎么设计</h2><p>hash函数是先拿到通过key 的hashcode，是32位的int值，然后让hashcode的高16位和低16位进行异或操作。<br>扰乱函数优点:</p><ul><li><p>一定要尽可能降低hash碰撞，越分散越好；</p></li><li><p>算法一定要尽可能高效，因为这是高频操作,位运算更高效<br>Java1.8相比1.7做了调整，1.7做了四次移位和四次异或，但明显Java 8觉得扰动做一次就够了，做4次的话，多了可能边际效用也不大，所谓为了效率考虑就改成一次。</p></li></ul><h2 id="4、java8优化"><a href="#4、java8优化" class="headerlink" title="4、java8优化"></a>4、java8优化</h2><ul><li><p>数组+链表改成了数组+链表或红黑树；</p></li><li><p>链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7将新元素放到数组中，原始节点作为新节点的后继节点，1.8遍历链表，将元素放置到链表的最后；</p></li><li><p>扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；</p></li><li><p>在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩</p></li></ul><h2 id="5、HashMap-在-JDK-1-7-和-JDK-1-8-中为什么不安全："><a href="#5、HashMap-在-JDK-1-7-和-JDK-1-8-中为什么不安全：" class="headerlink" title="5、HashMap 在 JDK 1.7 和 JDK 1.8 中为什么不安全："></a>5、HashMap 在 JDK 1.7 和 JDK 1.8 中为什么不安全：</h2><ul><li><p>JDK 1.7：由于采用头插法改变了链表上元素的的顺序，并发环境下扩容可能导致循环链表的问题 </p></li><li><p>JDK 1.8：由于 put 操作并没有上锁，并发环境下可能发生某个线程插入的数据被覆盖的问</p></li></ul><h2 id="6、如何保证-HashMap-线程安全？"><a href="#6、如何保证-HashMap-线程安全？" class="headerlink" title="6、如何保证 HashMap 线程安全？"></a>6、如何保证 HashMap 线程安全？</h2><ul><li><p>使用 java.util.Collections 类的 synchronizedMap 方法包装一下 HashMap，得到线程安全的 HashMap，其原理就是对所有的修改操作都加上 synchronized</p></li><li><p>使用线程安全的 HashTable 类代替，该类在对数据操作的时候都会上锁，也就是加上 synchronized</p></li><li><p>使用线程安全的 ConcurrentHashMap 类代替，该类在 JDK 1.7 和 JDK 1.8 的底层原理有所不同，JDK 1.7 采用数组 + 链表存储数据，使用分段锁 Segment 保证线程安全；JDK 1.8 采用数组 + 链表&#x2F;红黑树存储数据，使用 CAS + synchronized 保证线程安全。</p></li></ul><h2 id="7、HashMap-是否有序"><a href="#7、HashMap-是否有序" class="headerlink" title="7、HashMap 是否有序"></a>7、HashMap 是否有序</h2><p>hashMap无序因为hashCode冲突，要实现按插入顺序输出需要LinkHashMap，treeMap</p><ul><li><p>LinkHashMap </p></li><li><p>数据结构双向链表</p><p><img src="/../images/HashMap/1.png" alt="1"> 实现<br><img src="/../images/HashMap/2.png" alt="img"></p></li></ul><h2 id="8、基于LinkHashMap-实现LRU"><a href="#8、基于LinkHashMap-实现LRU" class="headerlink" title="8、基于LinkHashMap 实现LRU"></a>8、基于LinkHashMap 实现LRU</h2><p><img src="/../images/HashMap/2.png" alt="img"></p><p><img src="/../images/HashMap/4.png" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/22/redis/"/>
      <url>/2023/02/22/redis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>completaFuture.md</title>
      <link href="/2023/02/22/completaFuture/"/>
      <url>/2023/02/22/completaFuture/</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.whenComplete()：用于接收带有返回值的CompletableFuture对象，无法修改返回值。</span><br><span class="line"></span><br><span class="line">CompletableFuture.exceptionally()：用于处理异常，只要异步线程中有抛出异常，则进入该方法，修改返回值。</span><br><span class="line"></span><br><span class="line">CompletableFuture.handle()：用于处理返回结果，可以接收返回值和异常，可以对返回值进行修改。</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 异步起线程执行业务 无返回值</span><br><span class="line">CompletableFuture&lt;Void&gt; voidCompletableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span><br><span class="line">    int i = 10 / 2;</span><br><span class="line">    System.out.println(&quot;运行结果：&quot; + i);</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//异步起线程执行业务 有返回值</span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span><br><span class="line">    int i = 10 / 0;</span><br><span class="line">    System.out.println(&quot;运行结果：&quot; + i);</span><br><span class="line">    return i;</span><br><span class="line">&#125;, executor).whenComplete((res,exc)-&gt;&#123;</span><br><span class="line">    // 可以接收到返回值和异常类型，但是无法处理异常</span><br><span class="line">    System.out.println(&quot;异步任务成功完成了...结果是：&quot; + res + &quot;;异常是：&quot; + exc);</span><br><span class="line">&#125;).exceptionally(throwable -&gt; &#123;</span><br><span class="line">    // 处理异常，返回一个自定义的值，和上边返回值无关。</span><br><span class="line">    return 10;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//方法执行完成后的处理</span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span><br><span class="line">    int i = 10 / 0;</span><br><span class="line">    System.out.println(&quot;运行结果：&quot; + i);</span><br><span class="line">    return i;</span><br><span class="line">&#125;, executor).handle((res,thr)-&gt;&#123;</span><br><span class="line">    // 无论线程是否正确执行，都会执行这里，可以对返回值进行操作。</span><br><span class="line">    if(res != null)&#123;</span><br><span class="line">        return res * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    if(thr != null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-线程串行方法"><a href="#2-线程串行方法" class="headerlink" title="2. 线程串行方法"></a>2. 线程串行方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使线程串行执行，无入参，无返回值</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action, Executor executor)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使线程串行执行，有入参，无返回值</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action, Executor executor)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使线程串行执行，有入参，有返回值</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span>;</span><br></pre></td></tr></table></figure><h2 id="3-两任务并行执行完成，再执行新任务"><a href="#3-两任务并行执行完成，再执行新任务" class="headerlink" title="3. 两任务并行执行完成，再执行新任务"></a>3. 两任务并行执行完成，再执行新任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程并行执行完成，并且执行新任务action，新任务无入参，无返回值</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程并行执行完成，并且执行新任务action，新任务有入参，无返回值</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; action, Executor executor)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程并行执行完成，并且执行新任务action，新任务有入参，有返回值</span></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn, Executor executor)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务1</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1线程：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1结束：&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务2</span></span><br><span class="line">CompletableFuture&lt;String&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2线程：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务1和任务2都完成，在不使用任务1和任务2的返回值情况下执行任务3，并且任务3没有返回值</span></span><br><span class="line">CompletableFuture&lt;Void&gt; future1 = future01.runAfterBothAsync(future02,</span><br><span class="line">                                                             () -&gt; System.out.println(<span class="string">&quot;任务3开始&quot;</span>), executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务1和任务2都完成，使用任务1和任务2的返回值情况下执行任务3，并且任务3没有返回值</span></span><br><span class="line">CompletableFuture&lt;Void&gt; future2 = future01.thenAcceptBothAsync(future02,</span><br><span class="line">                                                               (f1, f2) -&gt; System.out.println(<span class="string">&quot;任务3开始，之前的结果&quot;</span> + f1 + <span class="string">&quot;--&gt;&quot;</span> + f2),</span><br><span class="line">                                                               executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务1和任务2都完成，使用任务1和任务2的返回值情况下执行任务3，并且任务3有返回值</span></span><br><span class="line">CompletableFuture&lt;String&gt; future3 = future01.thenCombineAsync(future02,</span><br><span class="line">                                                              (f1, f2) -&gt; f1 + <span class="string">&quot;:&quot;</span> + f2 + <span class="string">&quot;-&gt;haha&quot;</span>, </span><br><span class="line">                                                              executor);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> future3.get();</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-两任务并行执行，其中一个执行完，就执行新任务"><a href="#4-两任务并行执行，其中一个执行完，就执行新任务" class="headerlink" title="4. 两任务并行执行，其中一个执行完，就执行新任务"></a>4. 两任务并行执行，其中一个执行完，就执行新任务</h2><p>​         <strong>两任务并行执行，只要其中有一个执行完，就开始执行新任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务并行执行，只要其中有一个执行完，就开始执行新任务action，新任务无入参，无返回值</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务并行执行，只要其中有一个执行完，就开始执行新任务action，新任务有入参（入参类型为Object，因为不确定是哪个任务先执行完成），无返回值</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action,Executor executor)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务并行执行，只要其中有一个执行完，就开始执行新任务action，新任务有入参（入参类型为Object，因为不确定是哪个任务先执行完成），有返回值</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn,Executor executor)</span>;</span><br></pre></td></tr></table></figure><h2 id="5-多任务组合"><a href="#5-多任务组合" class="headerlink" title="5. 多任务组合"></a>5. 多任务组合</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs);</span><br><span class="line">public static CompletableFuture&lt;Object&gt; allof(CompletableFuture&lt;?&gt;... cfs);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/22/%E6%96%B9%E6%A1%88/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/02/22/%E6%96%B9%E6%A1%88/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/22/%E4%BB%A3%E7%A0%81/Untitled%201/"/>
      <url>/2023/02/22/%E4%BB%A3%E7%A0%81/Untitled%201/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/22/%E6%9C%89%E7%94%A8%E5%8D%95%E8%AF%8D/"/>
      <url>/2023/02/22/%E6%9C%89%E7%94%A8%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><figcaption><span>分配</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distribution： 分配</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/22/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/22/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/22/hello-world/"/>
      <url>/2023/02/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kafak总结</title>
      <link href="/2022/12/15/kafak/"/>
      <url>/2022/12/15/kafak/</url>
      
        <content type="html"><![CDATA[<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><blockquote><p>多副本机制</p></blockquote><p>主副本和从副本，从副本只负责同步主副本数据，只有主副本进行读写。</p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>网络结构设计</p><p>多路复用</p><p>多selector -&gt; 多线程-&gt; 多队列 </p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ul><li>把数据先写入os cache</li><li>然后顺序写入磁盘</li></ul><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><ul><li>根据稀疏索引快速定位到要消费消息</li><li>零拷贝机制，减少上下文切换和cpu拷贝</li></ul><h2 id="如何提高吞吐量"><a href="#如何提高吞吐量" class="headerlink" title="如何提高吞吐量"></a>如何提高吞吐量</h2><ul><li>设置缓存区数据量</li><li>开启压缩</li><li>设置合适批大小batch.size， 太小网络请求频繁，太大导致发送消息慢</li></ul><h2 id="重试机制带来问题"><a href="#重试机制带来问题" class="headerlink" title="重试机制带来问题"></a>重试机制带来问题</h2><ul><li>消息会重复： 幂等支持</li><li>消息乱序：  <code>max.in.flight.requests.per.connection</code>&#x3D;1  producer 同一时间只能发送一条消息，默认重试间隔： <code>retry.backoff.ms</code>&#x3D;100</li></ul><h2 id="偏移量管理"><a href="#偏移量管理" class="headerlink" title="偏移量管理"></a>偏移量管理</h2><p>每个consumer内存里数据结构保存对每个topic的每个分区的消费offset，定期会提交offset,老kafak写入<code>zookeeper</code>（废弃）。</p><p>提交offset发送给<code>kafka</code>内部topic：__consumer_offsets，提交过去的时候， key是<code>group.id</code>+topic+分区号，value就是当前offset的值，每隔一段时间，<code>kafka</code>内部会对这个topic进行compact(合并)，也就是每个<code>group.id</code>+topic+分区号就保留最新数据</p><h2 id="消费异常感知"><a href="#消费异常感知" class="headerlink" title="消费异常感知"></a>消费异常感知</h2><ul><li><code>heartbeat.interval.ms：consumer</code>心跳时间间隔，必须得与coordinator保持心跳才能知道consumer是否故障了， 然后如果故障之后，就会通过心跳下发<code>rebalance</code>的指令给其他的consumer通知他们进行<code>rebalance</code>的操作</li><li><code>session.timeout.ms</code>：<code>kafka</code>多长时间感知不到一个consumer就认为他故障了，默认是10</li><li><code>max.poll.interval.ms</code>：如果在两次poll操作之间，超过了这个时间，那么就会认为这个consume处理能力太弱了，会被踢出消费组，分区分配给别人去消费，一般来说结合业务处理的性能来设置就可以了。</li></ul><h2 id="消费者是如何实现rebalance的？"><a href="#消费者是如何实现rebalance的？" class="headerlink" title="消费者是如何实现rebalance的？"></a>消费者是如何实现rebalance的？</h2><blockquote><p>根据coordinator实现</p></blockquote><ul><li><ol><li>什么是coordinator 每个consumer group都会选择一个broker作为自己的coordinator，他是负责监控这个消费组里的各个消费者的心跳，以及判断是否宕机，然后开启rebalance的</li></ol></li><li><p>如何选择coordinator机器 首先对groupId进行hash（数字），接着对__consumer_offsets的分区数量取模，默认是50，_consumer_offsets的分区数可以通过offsets.topic.num.partitions来设置，找到分区以后，这个分区所在的broker机器就是coordinator机器。比如说：groupId，“myconsumer_group” -&gt; hash值（数字）-&gt; 对50取模 -&gt; 8 __consumer_offsets 这个主题的8号分区在哪台broker上面，那一台就是coordinator 就知道这个consumer group下的所有的消费者提交offset的时候是往哪个分区去提交offset，</p></li><li><p>(1)每个consumer都发送<code>JoinGroup</code>请求到Coordinator,然后Coordinator从一个consumer group中选择一个consumer作为leader(第一个)，Coordinator把consumer group情况发送给这个leader，leader定制消费方案，通过SyncGroup发给Coordinator，接着Coordinator就把消费方案下发给各个consumer，他们会从指定的分区的 leader broker开始进行socket连接以及消费消息。</p></li></ul><h2 id="谈谈Kafka客户端如何巧妙解决JVM-GC问题？"><a href="#谈谈Kafka客户端如何巧妙解决JVM-GC问题？" class="headerlink" title="谈谈Kafka客户端如何巧妙解决JVM GC问题？"></a>谈谈Kafka客户端如何巧妙解决JVM GC问题？</h2><h3 id="1-Kafka-客户端缓冲机制"><a href="#1-Kafka-客户端缓冲机制" class="headerlink" title="1. Kafka 客户端缓冲机制"></a>1. <strong>Kafka 客户端缓冲机制</strong></h3><p>kafak Produer 流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1）进行 Producer 初始化，加载配置参数，开启网络线程。</span><br><span class="line"></span><br><span class="line">2）执行拦截器逻辑，预处理消息, 封装 Producer Record。</span><br><span class="line"></span><br><span class="line">3）调用 Serializer.serialize() 方法进行消息的 key/value 序列化。</span><br><span class="line"></span><br><span class="line">4）调用 partition() 选择合适的分区策略，给消息体 Producer Record 分配要发送的 Topic 分区号。</span><br><span class="line"></span><br><span class="line">5）从 Kafka Broker 集群获取集群元数据 metadata。</span><br><span class="line"></span><br><span class="line">6）将消息缓存到 RecordAccumulator 收集器中, 最后判断是否要发送。这个加入消息收集器，首先得从 Deque&lt;RecordBatch&gt; 里找到自己的目标分区，如果没有就新建一个 Batch 消息 Deque 加进入。</span><br><span class="line"></span><br><span class="line">7）当达到发送阈值，唤醒 Sender 线程，实例化 NetWorkClient 将 batch record 转换成 request client 的发送消息体, 并将待发送的数据按 【Broker Id &lt;=&gt; List】的数据进行归类。</span><br><span class="line"></span><br><span class="line">8）与服务端不同的 Broker 建立网络连接，将对应 Broker 待发送的消息 List 发送出去。</span><br><span class="line"></span><br><span class="line">9）批次发送的条件为: 缓冲区数据大小达到 batch.size 或者 linger.ms 达到上限，哪个先达到就算哪个。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Kafka 实现的缓冲机制</strong> ,减少垃圾回收，降低STW</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 Kafka 客户端内部，针对这个问题实现了一个非常优秀的机制，就是「缓冲池机制」。即每个 Batch 底层都对应一块内存空间，这个内存空间就是专门用来存放写进去的消息。</span><br><span class="line"></span><br><span class="line">当一个 Batch 数据被发送到了 kafka 服务端，这个 Batch 的内存空间不再使用了。此时这个 Batch 底层的内存空间先不交给 JVM 去垃圾回收，而是把这块内存空间给放入一个缓冲池里。</span><br><span class="line"></span><br><span class="line">这个缓冲池里存放了很多块内存空间，下次如果有一个新的 Batch 数据了，那么直接从缓冲池获取一块内存空间是不是就可以了？然后如果一个 Batch 数据发送出去了之后，再把内存空间还回来是不是就可以了？以此类推，循环往复。</span><br></pre></td></tr></table></figure><h2 id="kafka开启精确发送一次"><a href="#kafka开启精确发送一次" class="headerlink" title="kafka开启精确发送一次"></a><code>kafka</code>开启精确发送一次</h2><p>通过引入「<code>PID</code>及Sequence Number」支持幂等性，保证精确一次「exactly once」语义。</p><p>其中启用幂等传递的方法配置：<code>enable.idempotence</code> &#x3D; true。启用事务支持的方法配置：设置属性 <code>transcational.id </code>&#x3D; “指定值”。</p><h2 id="谈谈你对Kafka控制器及选举机制是如何理解"><a href="#谈谈你对Kafka控制器及选举机制是如何理解" class="headerlink" title="谈谈你对Kafka控制器及选举机制是如何理解"></a>谈谈你对Kafka控制器及选举机制是如何理解</h2><p>所谓的控制器「Controller」就是通过 ZooKeeper 来管理和协调整个 Kafka 集群的组件。集群中任意一台 Broker 都可以充当控制器的角色，但是在正常运行过程中，只能有一个 Broker 成为控制器。</p><p>控制器的职责主要包括：</p><p>1）集群元信息管理及更新同步 (Topic路由信息等)。</p><p>2）主题管理（创建、删除、增加分区等）。</p><p>3）分区重新分配。</p><p>4）副本故障转移、 Leader 选举、ISR 变更。</p><p>5）集群成员管理（通过 watch 机制自动检测新增 Broker、Broker 主动关闭、Broker 宕机等）。</p><p>在2.x中 zookeeper作用： 帮助kafka选择controller ，通知controller节点关闭或者加入</p><p>Kafka 3.X 版本中，内部实现一个类似于 Raft 的共识算法来选举 Controller</p><h2 id="HW-和LEO-理解"><a href="#HW-和LEO-理解" class="headerlink" title="HW 和LEO 理解"></a>HW 和LEO 理解</h2><p>HW 作用：</p><p>1）用来标识分区下的哪些消息是可以被消费者消费的。</p><p>2）协助 Kafka 完成副本数据同步。</p><p>LEO 作用：</p><p>1）如果 Follower 和 Leader 的 LEO 数据同步了, 那么 HW 就可以更新了。</p><p>2）HW 之前的消息数据对消费者是可见的，属于 commited 状态,  HW 之后的消息数据对消费者是不可见的。</p><h2 id="谈谈-Kafka-消息分配策略都有哪些？"><a href="#谈谈-Kafka-消息分配策略都有哪些？" class="headerlink" title="谈谈 Kafka 消息分配策略都有哪些？"></a>谈谈 Kafka 消息分配策略都有哪些？</h2><ul><li><p>RangeAssignor 是 Kafka 默认的分区分配算法，它是按照 Topic 的维度进行分配的，首先对 每个Topic 的 Partition 按照分区ID进行排序，然后对订阅该 Topic 的 Consumer Group 的 Consumer 按名称字典进行排序，之后尽量均衡的按照范围区段将分区分配给 Consumer。此时也可能会造成先分配分区的 Consumer 任务过重（分区数无法被消费者数量整除）</p></li><li><p>RoundRobinAssignor： </p></li><li><p>该分区分配策略是将 Consumer Group 订阅的所有 Topic 的 Partition 及所有 Consumer 按照字典进行排序后尽量均衡的挨个进行分配。如果 Consumer Group 内，每个 Consumer 订阅都订阅了相同的Topic，那么分配结果是均衡的。如果订阅 Topic 是不同的，那么分配结果是不保证「 尽量均衡」的，因为某些 Consumer 可能不参与一些 Topic 的分配</p></li><li><p>StickyAssignor</p><p>该分区分配算法是最复杂的一种，可以通过 partition.assignment.strategy 参数去设置，从 0.11 版本开始引入，目的就是在执行新分配时，尽量在上一次分配结果上少做调整，其主要实现了以下2个目标：</p><p>1、Topic Partition 的分配要尽量均衡。</p><p>2、当 Rebalance 发生时，尽量与上一次分配结果保持一致。</p></li></ul><h2 id="Rebalance-触发后如何通知其他-Consumer-进程？"><a href="#Rebalance-触发后如何通知其他-Consumer-进程？" class="headerlink" title="Rebalance 触发后如何通知其他 Consumer 进程？"></a>Rebalance 触发后如何通知其他 Consumer 进程？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rebalance 的通知机制就是靠 Consumer 端的心跳线程，它会定期发送心跳请求到 Broker 端的 Coordinator 协调者组件,当协调者决定开启 Rebalance 后，它会将「REBALANCE_IN_PROGRESS」封装进心跳请求的响应中发送给 Consumer ,当 Consumer 发现心跳响应中包含了「REBALANCE_IN_PROGRESS」，就知道是 Rebalance 开始了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="谈谈Kafka线上大量消息积压你是如何处理的？"><a href="#谈谈Kafka线上大量消息积压你是如何处理的？" class="headerlink" title="谈谈Kafka线上大量消息积压你是如何处理的？"></a>谈谈Kafka线上大量消息积压你是如何处理的？</h2><p>事前：</p><ul><li>避免大消息发送</li><li>分区数和消费组数尽量相等</li><li>优化消费端逻辑，避免重平衡</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oauth2学习</title>
      <link href="/2022/09/15/oauth2/"/>
      <url>/2022/09/15/oauth2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-角色"><a href="#1-角色" class="headerlink" title="1.  角色"></a>1.  角色</h2><ul><li><p><strong>Resource Owner :资源拥有者</strong></p></li><li><h5 id="Resource-Server-资源服务器"><a href="#Resource-Server-资源服务器" class="headerlink" title="Resource Server 资源服务器"></a>Resource Server 资源服务器</h5></li><li><p><strong>Client 客户端</strong></p></li><li><h5 id="Authorization-server-授权服务器"><a href="#Authorization-server-授权服务器" class="headerlink" title="Authorization server 授权服务器"></a>Authorization server 授权服务器</h5></li></ul><h2 id="2-大致流程"><a href="#2-大致流程" class="headerlink" title="2  大致流程"></a>2  大致流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--------+                               +---------------+</span><br><span class="line">    |        |--(A)- Authorization Request -&gt;|   Resource    |</span><br><span class="line">    |        |                               |     Owner     |</span><br><span class="line">    |        |&lt;-(B)-- Authorization Grant ---|               |</span><br><span class="line">    |        |                               +---------------+</span><br><span class="line">    |        |</span><br><span class="line">    |        |                               +---------------+</span><br><span class="line">    |        |--(C)-- Authorization Grant --&gt;| Authorization |</span><br><span class="line">    | Client |                               |     Server    |</span><br><span class="line">    |        |&lt;-(D)----- Access Token -------|               |</span><br><span class="line">    |        |                               +---------------+</span><br><span class="line">    |        |</span><br><span class="line">    |        |                               +---------------+</span><br><span class="line">    |        |--(E)----- Access Token ------&gt;|    Resource   |</span><br><span class="line">    |        |                               |     Server    |</span><br><span class="line">    |        |&lt;-(F)--- Protected Resource ---|               |</span><br><span class="line">    +--------+                               +---------------+</span><br></pre></td></tr></table></figure><h2 id="3-具体实现方式"><a href="#3-具体实现方式" class="headerlink" title="3 . 具体实现方式"></a>3 . 具体实现方式</h2><h3 id="3-1-授权码模式"><a href="#3-1-授权码模式" class="headerlink" title="3.1  授权码模式"></a>3.1  授权码模式</h3><blockquote><p>授权码授予类型是一种安全的方式来获取访问令牌和刷新令牌。它涉及客户端将用户重定向到授权服务器，用户可以授予客户端访问其资源的权限。然后，授权服务器将授权码发送回客户端，可以用来兑换访问令牌。然后，可以使用访问令牌来访问用户的资源。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">     | Resource |</span><br><span class="line">     |   Owner  |</span><br><span class="line">     |          |</span><br><span class="line">     +----------+</span><br><span class="line">          ^</span><br><span class="line">          |</span><br><span class="line">         (B)</span><br><span class="line">     +----|-----+          Client Identifier      +---------------+</span><br><span class="line">     |         -+----(A)-- &amp; Redirection URI ----&gt;|               |</span><br><span class="line">     |  User-   |                                 | Authorization |</span><br><span class="line">     |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |</span><br><span class="line">     |          |                                 |               |</span><br><span class="line">     |         -+----(C)-- Authorization Code ---&lt;|               |</span><br><span class="line">     +-|----|---+                                 +---------------+</span><br><span class="line">       |    |                                         ^      v</span><br><span class="line">      (A)  (C)                                        |      |</span><br><span class="line">       |    |                                         |      |</span><br><span class="line">       ^    v                                         |      |</span><br><span class="line">     +---------+                                      |      |</span><br><span class="line">     |         |&gt;---(D)-- Authorization Code ---------<span class="string">&#x27;      |</span></span><br><span class="line"><span class="string">     |  Client |          &amp; Redirection URI                  |</span></span><br><span class="line"><span class="string">     |         |                                             |</span></span><br><span class="line"><span class="string">     |         |&lt;---(E)----- Access Token -------------------&#x27;</span></span><br><span class="line">     +---------+       (w/ Optional Refresh Token)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gRPc实例</title>
      <link href="/2022/08/15/Java%E7%89%88gRPC/"/>
      <url>/2022/08/15/Java%E7%89%88gRPC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装protocbuf"><a href="#1-安装protocbuf" class="headerlink" title="1.安装protocbuf"></a>1.安装protocbuf</h2><ol><li><p><a href="https://link.zhihu.com/?target=https://github.com/protocolbuffers/protobuf/releases/tag/v3.19.1">下载protobuf</a> window版</p></li><li><p>配置环境变量： </p><p><code>变量名</code>：PROTOCBUF_HOME</p></li></ol><p>  <code>变量值</code>：D:\protoc-3.19.1-win64</p><p>找到系统变量中的<code>path</code>变量，选中后点击<code>编辑</code>，在<code>新建</code>的内容中输入：%PROTOBUF_HOME%\bin</p><ol start="3"><li>idea安装protocbuf插件</li></ol><h2 id="2-gRPC项目构建"><a href="#2-gRPC项目构建" class="headerlink" title="2. gRPC项目构建"></a>2. gRPC项目构建</h2><h3 id="1-插件"><a href="#1-插件" class="headerlink" title="1. 插件"></a>1. 插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;extensions&gt;</span><br><span class="line">    &lt;extension&gt;</span><br><span class="line">      &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.6.2&lt;/version&gt;</span><br><span class="line">    &lt;/extension&gt;</span><br><span class="line">  &lt;/extensions&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.6.1&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;protocArtifact&gt;com.google.protobuf:protoc:3.17.3:exe:$&#123;os.detected.classifier&#125;&lt;/protocArtifact&gt;</span><br><span class="line">        &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;</span><br><span class="line">        &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.42.0:exe:$&#123;os.detected.classifier&#125;&lt;/pluginArtifact&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">            &lt;goal&gt;compile-custom&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-netty-shaded&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.42.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-protobuf&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.42.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-stub&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.42.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt; &lt;!-- necessary for Java 9+ --&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;annotations-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;6.0.53&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-添加-proto文件"><a href="#2-添加-proto文件" class="headerlink" title="2. 添加.proto文件"></a>2. 添加.proto文件</h3><p>  一定要在和src&#x2F;main&#x2F;java源文件目录同级的proto源文件目录才可以。 </p><p>helloworld.proto</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; // 协议版本</span><br><span class="line"></span><br><span class="line">// 选项配置</span><br><span class="line">option java_package = &quot;com.cgh.protobuf&quot;;</span><br><span class="line">option java_outer_classname = &quot;RPCDateServiceApi&quot;;</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line"></span><br><span class="line">// 定义包名</span><br><span class="line">package com.cgh.protobuf;</span><br><span class="line"></span><br><span class="line">// 服务接口.定义请求参数和相应结果</span><br><span class="line">service RPCDateService &#123;</span><br><span class="line">  rpc getDate (RPCDateRequest) returns (RPCDateResponse) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义请求体</span><br><span class="line">message RPCDateRequest &#123;</span><br><span class="line">  string userName = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义响应内容</span><br><span class="line">message RPCDateResponse &#123;</span><br><span class="line">  string serverDate = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-用插件根据-proto文件生成消息体类文件和XXXGrpc类文件"><a href="#3-用插件根据-proto文件生成消息体类文件和XXXGrpc类文件" class="headerlink" title="3. 用插件根据.proto文件生成消息体类文件和XXXGrpc类文件"></a>3. 用插件根据.proto文件生成消息体类文件和XXXGrpc类文件</h3><ul><li><code>mvn protobuf:compile</code> 生成消息体类文件  （多次执行可能失败）</li><li><code>mvn protobuf:compile-custom</code> 生成XXXGrpc类文件  （多次执行可能失败)</li><li>把生成的消息体文件和 XXXGrpc 文件copy到项目</li></ul><h3 id="4-编写实现类"><a href="#4-编写实现类" class="headerlink" title="4. 编写实现类"></a>4. 编写实现类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import com.cgh.protobuf.RPCDateRequest;</span><br><span class="line">import com.cgh.protobuf.RPCDateResponse;</span><br><span class="line">import com.cgh.protobuf.RPCDateServiceGrpc;</span><br><span class="line">import io.grpc.stub.StreamObserver;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line">public class RPCDateServiceImpl extends RPCDateServiceGrpc.RPCDateServiceImplBase &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getDate(RPCDateRequest request, StreamObserver&lt;RPCDateResponse&gt; responseObserver) &#123;</span><br><span class="line">        //请求结果，我们定义的</span><br><span class="line">        RPCDateResponse rpcDateResponse = null;</span><br><span class="line">        //</span><br><span class="line">        String userName = request.getUserName();</span><br><span class="line">        String response = String.format(&quot;你好:%s,今天是%s.&quot;, userName, LocalDate.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;)));</span><br><span class="line">        try &#123;</span><br><span class="line">            // 定义响应,是一个builder构造器.</span><br><span class="line">            rpcDateResponse = RPCDateResponse.newBuilder()</span><br><span class="line">                    .setServerDate(response)</span><br><span class="line">                    .build();</span><br><span class="line">            //int i = 10/0;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            responseObserver.onError(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">            responseObserver.onNext(rpcDateResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-定义服务端"><a href="#5-定义服务端" class="headerlink" title="5. 定义服务端"></a>5. 定义服务端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GRPCServer &#123;</span><br><span class="line">    private static final int port = 9999;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">        //设置service端口</span><br><span class="line">        Server server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService(new RPCDateServiceImpl())</span><br><span class="line">                .build().start();</span><br><span class="line">        System.out.println(String.format(&quot;GRpc服务端启动成功, 端口号: %d.&quot;, port));</span><br><span class="line"></span><br><span class="line">        server.awaitTermination();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-定义客户端"><a href="#6-定义客户端" class="headerlink" title="6. 定义客户端"></a>6. 定义客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static final String host = &quot;localhost&quot;;</span><br><span class="line">    private static final int serverPort = 9999;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1,拿到一个通信channel</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forAddress(host, serverPort).</span><br><span class="line">                usePlaintext()//无需加密或认证</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            //2.拿到stub对象</span><br><span class="line">            RPCDateServiceGrpc.RPCDateServiceBlockingStub rpcDateService  = RPCDateServiceGrpc.newBlockingStub(channel);</span><br><span class="line">            RPCDateRequest rpcDateRequest = RPCDateRequest.newBuilder()</span><br><span class="line">                    .setUserName(&quot;JACK&quot;)</span><br><span class="line">                    .build();</span><br><span class="line">            //3,请求</span><br><span class="line">            RPCDateResponse rpcDateResponse = rpcDateService.getDate(rpcDateRequest);</span><br><span class="line">            //4,输出结果</span><br><span class="line">            System.out.println(rpcDateResponse.getServerDate());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 5.关闭channel, 释放资源.</span><br><span class="line">            channel.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JSON使用</title>
      <link href="/2022/08/15/fastjson/"/>
      <url>/2022/08/15/fastjson/</url>
      
        <content type="html"><![CDATA[<ol><li>泛型反序列化</li></ol><p>  <code>new TypeReference&lt;List&lt;User&gt;&gt;()</code><br>2. 如果数据对象中存在Map对象，为了保证序列化后的字段顺序一致，需要添加<code>SerializerFeature.MapSortField</code>特征。</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.toJSONString(userMap, SerializerFeature.MapSortField);</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>排除所有类的属性字段：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserVO&gt; userList = ...;SimplePropertyPreFilter filter = new SimplePropertyPreFilter();filter.getExcludes().addAll(Arrays.asList(&quot;gmtCreate&quot;, &quot;gmtModified&quot;));Assert.assertEquals(&quot;用户信息不一致&quot;, text, JSON.toJSONString(user, filter));</span><br></pre></td></tr></table></figure></li></ol><p> <strong>排除单个类的属性字段：</strong></p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserVO&gt; userList = ...;SimplePropertyPreFilter filter = new SimplePropertyPreFilter(UserVO.class);filter.getExcludes().addAll(Arrays.asList(&quot;gmtCreate&quot;, &quot;gmtModified&quot;));Assert.assertEquals(&quot;用户信息不一致&quot;, text, JSON.toJSONString(user, filter));</span><br></pre></td></tr></table></figure><p>   <strong>排查多个类属性：</strong></p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">Pair&lt;UserVO, CompanyVO&gt; userCompanyPair = ...;</span><br><span class="line">SimplePropertyPreFilter userFilter = new SimplePropertyPreFilter(UserVO.class);</span><br><span class="line">userFilter.getExcludes().addAll(Arrays.asList(&quot;gmtCreate&quot;, &quot;gmtModified&quot;));</span><br><span class="line">SimplePropertyPreFilter companyFilter = new SimplePropertyPreFilter(CompanyVO.class);</span><br><span class="line">companyFilter.getExcludes().addAll(Arrays.asList(&quot;createTime&quot;, &quot;modifyTime&quot;));</span><br><span class="line">Assert.assertEquals(&quot;用户公司对不一致&quot;, text, JSON.toJSONString(userCompanyPair, new SerializeFilter[]&#123;userFilter, companyFilter&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>es</title>
      <link href="/2022/08/15/es/"/>
      <url>/2022/08/15/es/</url>
      
        <content type="html"><![CDATA[<h2 id="1-十亿级数据ES搜索怎么优化"><a href="#1-十亿级数据ES搜索怎么优化" class="headerlink" title="1. 十亿级数据ES搜索怎么优化?"></a>1. 十亿级数据ES搜索怎么优化?</h2><blockquote><p>es 的搜索引擎严重依赖于底层的 <code>filesystem cache</code>，你如果给 <code>filesystem cache</code> 更多的内存，尽量让内存可以容纳所有的 <code>idx segment file</code> 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高</p></blockquote><ul><li>存尽量少字段  ，可以采用<code>es</code>+<code>hbase</code></li><li>数据预热，程序定时刷新数据到 <code>filesystem cache</code></li><li>冷热分离 ， 冷热数据单独建立索引，避免冷数据刷掉热数据的<code>filesystem cache</code></li><li>直接写入计算好数据，避免join操作</li><li>分页性能优化</li></ul><p>​    es 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p><h2 id="2-在数据量很大的情况下，怎么实现深度分页？"><a href="#2-在数据量很大的情况下，怎么实现深度分页？" class="headerlink" title="2. 在数据量很大的情况下，怎么实现深度分页？"></a>2. 在数据量很大的情况下，怎么实现深度分页？</h2><h2 id="3-es-读写数据过程-和检索过程"><a href="#3-es-读写数据过程-和检索过程" class="headerlink" title="3. es 读写数据过程 和检索过程"></a>3. es 读写数据过程 和检索过程</h2><h3 id="1-写"><a href="#1-写" class="headerlink" title="1. 写"></a>1. 写</h3><ul><li>客户端选择一个 node 发送请求过去，这个 node 就是 <code>coordinating node</code>（协调节点）。</li><li><code>coordinating node</code> 对 document 进行路由，将请求转发给对应的 node（有 primary shard）。</li><li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到 <code>replica node</code>。</li><li><code>coordinating node</code> 如果发现 <code>primary node</code> 和所有 <code>replica node</code> 都搞定之后，就返回响应结果给客户端。</li></ul><h3 id="2-读"><a href="#2-读" class="headerlink" title="2. 读"></a>2. 读</h3><p>可以通过 <code>doc id</code> 来查询，会根据 <code>doc id</code> 进行 hash，判断出来当时把 <code>doc id</code> 分配到了哪个 shard 上面去，从那个 shard 去查询。</p><ul><li>客户端发送请求到任意一个 node，成为 <code>coordinate node</code>。</li><li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code>随机轮询算法，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li><li>接收请求的 node 返回 document 给 <code>coordinate node</code>。</li><li><code>coordinate node</code> 返回 document 给客户端。</li></ul><h3 id="3-检索"><a href="#3-检索" class="headerlink" title="3.检索"></a>3.检索</h3><p>客户端发送请求到一个 <code>coordinate node</code>。</p><p>协调节点将搜索请求转发到所有的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code>，都可以。</p><p>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code>）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</p><p>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上拉取实际的 <code>document</code> 数据，最终返回给客户端。</p><p>​     </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>feign使用</title>
      <link href="/2022/08/15/feign/"/>
      <url>/2022/08/15/feign/</url>
      
        <content type="html"><![CDATA[<h2 id="1-feign-日志"><a href="#1-feign-日志" class="headerlink" title="1. feign 日志"></a>1. feign 日志</h2><h3 id="1-配置方式"><a href="#1-配置方式" class="headerlink" title="1. 配置方式"></a>1. 配置方式</h3><ol><li>基于配置文件修改feign的日志级别可以针对单个服务</li></ol>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign:  </span><br><span class="line">  client:</span><br><span class="line">    config: </span><br><span class="line">      userservice: # 针对某个微服务的配置</span><br><span class="line">        loggerLevel: FULL #  日志级别 </span><br></pre></td></tr></table></figure><ol start="2"><li>针对所有服务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feign:  </span><br><span class="line">  client:</span><br><span class="line">    config: </span><br><span class="line">      default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span><br><span class="line">        loggerLevel: FULL #  日志级别 </span><br></pre></td></tr></table></figure><h3 id="2-java-代码方式"><a href="#2-java-代码方式" class="headerlink" title="2. java 代码方式"></a>2. <code>java</code> 代码方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultFeignConfiguration  &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Logger.Level feignLogLevel()&#123;</span><br><span class="line">        return Logger.Level.BASIC; // 日志级别为BASIC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>全局</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration.class)</span><br></pre></td></tr></table></figure><ol start="2"><li>局部</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span><br></pre></td></tr></table></figure><h2 id="3-支持httpClient"><a href="#3-支持httpClient" class="headerlink" title="3. 支持httpClient"></a>3. 支持<code>httpClient</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--httpClient的依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      default: # default全局的配置</span><br><span class="line">        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息</span><br><span class="line">  httpclient:</span><br><span class="line">    enabled: true # 开启feign对HttpClient的支持</span><br><span class="line">    max-connections: 200 # 最大的连接数</span><br><span class="line">    max-connections-per-route: 50 # 每个路径的最大连接数</span><br></pre></td></tr></table></figure><h2 id="4-FeignClient整合Sentinel"><a href="#4-FeignClient整合Sentinel" class="headerlink" title="4. FeignClient整合Sentinel"></a>4. <code>FeignClient</code>整合Sentinel</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: true # 开启feign对sentinel的支持</span><br></pre></td></tr></table></figure><h2 id="5-feign-降级"><a href="#5-feign-降级" class="headerlink" title="5. feign 降级"></a>5. feign 降级</h2><ul><li><code>FallbackClass</code>无法对远程调用的异常做处理</li><li><code>FallbackFactory</code>，可以对远程调用的异常做处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>forkjion原理</title>
      <link href="/2022/08/15/forkJoin/"/>
      <url>/2022/08/15/forkJoin/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>forkJoin</code> 把大任务拆分成小任务，放到不同的队列中，每个队列对应一个线程进行处理</p></blockquote><p><code>forkJoinTask</code> 三个实现类：</p><ul><li><p>RecursiveAction</p><p>无结果返回的任务</p></li><li><p>RecursiveTask</p><p>有返回结果的任务</p></li><li><p>CountedCompleter</p><p>无返回值任务，完成任务后可以触发回调</p></li></ul><h2 id="工作窃取（-work-stealing-）算法"><a href="#工作窃取（-work-stealing-）算法" class="headerlink" title="工作窃取（ work-stealing ）算法"></a>工作窃取（ work-stealing ）算法</h2><blockquote><p>闲的线程试图从繁忙线程的 <code>deques</code> 中 窃取工作</p></blockquote><p>默认情况下，每个工作线程从其自己的双端队列中获取任务。但如果自己的双端队列中的任务已经执行完毕，双端队列为空时，工作线程就会从另一个忙线程的双端队列尾部或全局入口队列中获取任务，因为这是最大概率可能找到工作的地方</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2022/08/15/jvm/"/>
      <url>/2022/08/15/jvm/</url>
      
        <content type="html"><![CDATA[<h2 id="1-工具"><a href="#1-工具" class="headerlink" title="1.工具"></a>1.工具</h2><ul><li><p>jps</p></li><li><p>jinfo ： 查看配置</p></li><li><p>jvisualvm</p></li><li><p>jconsole</p><h3 id="1-1-jmap"><a href="#1-1-jmap" class="headerlink" title="1.1 jmap"></a>1.1 jmap</h3><blockquote><p> jmap [options] pid</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to print class loader statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure><h3 id="1-2-jstack"><a href="#1-2-jstack" class="headerlink" title="1.2 jstack"></a>1.2 jstack</h3><h3 id="1-3-jmap"><a href="#1-3-jmap" class="headerlink" title="1.3 jmap"></a>1.3 jmap</h3></li></ul><h2 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2. 垃圾回收"></a>2. 垃圾回收</h2><p>我们进行MinorGC，会不会有对象被老年代引用着？进行OldGC会不会又有对象被年轻代引用着？</p><p>那我们进行MinorGC的时候不光要管GC Roots，还有再去遍历老年代，这个性能问题就很大了。</p><p>解决方案： </p><p><strong>跨代引用相对于同代引用来说仅占极少数</strong>。</p><p>由此就产生了一个新的解决方案，我们不用去扫描整个老年代了，只要在年轻代建立一个数据结构，叫做记忆集Remembered Set，他把老年代划分为N个区域，标志出哪个区域会存在跨代引用。以后在进行MinorGC的时候，只要把这些包含了跨代引用的内存区域加入GC Roots一起扫描就行了。</p><p>卡表实际上就是记忆集的一种实现方式，如果说记忆集是接口的话，那么卡表就是他的实现类。</p><p>实际上卡表就是映射了一块块的内存地址，这些内存地址块称为<strong>卡页</strong></p><p>只要一个卡页内的对象存在一个或者多个跨代对象指针，就将该位置的卡表数组元素修改为1，表示这个位置为脏，没有则为0。</p><p>在GC的时候，就直接把值为1对应的卡页对象指针加入GC Roots一起扫描即可。</p><p><strong>三色标记</strong></p><ol><li>白色，在刚开始遍历的时候，所有的对象都是白色的</li><li>灰色，被垃圾回收器扫描过，但是至少还有一个引用没有被扫描</li><li>黑色，被垃圾回收器扫描过，并且这个对象的引用也全部都被扫描过，是安全存活的对象</li></ol><p><strong>三色标记的问题</strong></p><p>存活对象标记成需要清理，同时满足一下两种场景才会出现</p><ol><li>插入了一条或者多条黑色到白色对象的引用</li><li>删除了全部从灰色到白色对象的引用</li></ol><p>决绝方案：</p><p> <strong>增量更新</strong>和<strong>原始快照</strong> ： CMS使用的是增量更新，而像G1则是使用原始快照</p><p> 增量更新解决方案就是，他会把这些新插入的引用记录下来，扫描结束之后，再以黑色对象为根重新扫描一次。</p><p> 原始快照则是去破坏第二个条件，他把这个要删除的引用记录下来，扫描结束之后，以灰色对象为根重新扫描一次。所以就像是快照一样，不管你删没删，其实最终还是会按照之前的关系重新来一次</p><p><strong>G1使用场景</strong>：</p><p>1、50%以上的堆被存活对象占用：当大多数对象都存活的时候，说明老年代被占用的比例也会很大，这个时候就会触发full gc，full gc是很慢的，如果我们使用G1，那么G1就会触发mixed gc，而且mixed gc的GC最大停顿时间还是可控的。<br>2、对象分配和晋升的速度变化非常大：说明了对象往老年代挪动的频率很频繁，一样的，可以减少full gc的发生。<br>3、垃圾回收时间特别长，超过1秒：可以设置停顿时间，提升用户体验。<br>4、8GB以上的堆内存(建议值)：内存如果在8G以下，收集的垃圾不是很多，而G1的算法相对于CMS较为复杂，还很有可能效率不如CMS，但是对于大内存，STW时间比较长，所以，在可控停顿时间这里，G1比较合适。<br>5、停顿时间是500ms以内：停顿时间可由用户控制。</p><p><strong>为什么CMS用增量更新，G1用原始快照（SATB）</strong></p><ol><li>因为增量更新之后会重新深度扫描，G1是以region的方式存储对象，而CMS是以一个连续的老年代存储对象，G1会涉及到跨代扫描，G1的代价相对于CMS要高。</li><li>而且G1较CMS更强调用户体验，重新深度扫描会加大STW时间，所以G1选择原始快照。</li></ol><h2 id="3-调优"><a href="#3-调优" class="headerlink" title="3.调优"></a>3.调优</h2><h3 id="3-1-JVM调优的时机"><a href="#3-1-JVM调优的时机" class="headerlink" title="3.1  JVM调优的时机"></a>3.1  JVM调优的时机</h3><ul><li>Heap内存（老年代）持续上涨达到设置的最大内存值；</li><li>Full GC 次数频繁；</li><li>GC 停顿时间过长（超过1秒）；</li><li>应用出现OutOfMemory 等内存异常；</li><li>应用中有使用本地缓存且占用大量内存空间；</li><li>系统吞吐量与响应性能不高或下降。</li></ul><h3 id="3-2-JVM调优的目标"><a href="#3-2-JVM调优的目标" class="headerlink" title="3.2  JVM调优的目标"></a>3.2  <strong>JVM调优的目标</strong></h3><ul><li>延迟：GC低停顿和GC低频率；</li><li>低内存占用；</li><li>高吞吐量;</li></ul><h3 id="2-3-JVM调优的步骤"><a href="#2-3-JVM调优的步骤" class="headerlink" title="2.3 JVM调优的步骤"></a>2.3 <strong>JVM调优的步骤</strong></h3><ul><li>分析系统系统运行情况：分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</li><li>确定JVM调优量化目标；</li><li>确定JVM调优参数（根据历史JVM参数来调整）；</li><li>依次确定调优内存、延迟、吞吐量等指标；</li><li>对比观察调优前后的差异；</li><li>不断的分析和调整，直到找到合适的JVM参数配置；</li><li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</li></ul><h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4.问题"></a>4.问题</h2><h3 id="4-1-为什么用元空间替代永久代"><a href="#4-1-为什么用元空间替代永久代" class="headerlink" title="4.1 为什么用元空间替代永久代?"></a>4.1 为什么用元空间替代永久代?</h3><ul><li>降低OOM</li><li>降低维护成本，元空间采取本地内存，不需要单独调优参数</li></ul><p>​     永久代和元空间都是 HotSpot 虚拟机对《Java 虚拟机规范》中方法区的实现，在 JDK 1.8 之前 HotSpot 是使用永久代来实现方法区的，但这样会导致 JVM 调优比较困难，且容易发生 OOM 的问题，而 JDK 1.8 及之后，使用的是元空间存放在本地内存中的方式来替代永久代的，这样就降低了 OOM 发生的可能性，也是 JRockit 和 HotSpot 融合之后的改动之一。</p><ol><li>JDK 1.6 及之前：方法区使用永久代实现，<strong>静态变量存放在永久代</strong>；</li><li>JDK 1.7 ：“去永久代”的前置版本，还存在永久代，不过<strong>已经将字符串常量池和静态变量从永久代移到了堆上</strong>；</li><li>JDK 1.8 及以后：<strong>无永久代，使用元空间（存放在本地内存中）实现方法区，常量保存在元空间，但字符串常量池和静态变量依然保存在堆中</strong>。</li></ol><h3 id="4-2-CMS"><a href="#4-2-CMS" class="headerlink" title="4.2 CMS"></a>4.2 CMS</h3><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul><p>CMS缺点：</p><p>   吞吐量低，<strong>对 CPU 资源消耗较大</strong> ,无法处理浮动垃圾(漏标+并发清除阶段产生)，采用标记清除算法产生内存碎片，并发模式失败后切换 seria old</p><h2 id="5-G1-垃圾回收器"><a href="#5-G1-垃圾回收器" class="headerlink" title="5.G1 垃圾回收器"></a>5.G1 垃圾回收器</h2><p><strong>第一种：年轻代垃圾回收 YoungGC</strong></p><p>YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC。</p><p><strong>第二种，混合垃圾回收，MixedGC</strong></p><p>不是FullGC，老年代的堆占有率达到设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及<strong>大对象区</strong>，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现<strong>没有足够的空region</strong>能够承载拷贝对象就会触发一次Full GC。</p><p><strong>第三种，Full GC</strong></p><p>停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了</p><h3 id="4-1-G1垃圾收集器优化建议"><a href="#4-1-G1垃圾收集器优化建议" class="headerlink" title="4.1 G1垃圾收集器优化建议"></a>4.1 <strong>G1垃圾收集器优化建议</strong></h3><p>   调优  -XX:MaxGCPauseMills 时间，避免频繁youngGC 和 大量对象快速进入老年代。</p><h2 id="5-实际使用jvm调优配置参考"><a href="#5-实际使用jvm调优配置参考" class="headerlink" title="5.实际使用jvm调优配置参考"></a>5.实际使用jvm调优配置参考</h2><p><strong>2.1 通用型:</strong></p><p>开发(模板4)+测试(模板4)+预发(模板2)+生产(模板2)</p><p><strong>2.2 并发型:</strong></p><p>开发(模板3)+测试(模板3)+预发(模板1)+生产(模板1)</p><p><strong>2.3 IO密集型(测试中,如需配置请联系架构师评估):</strong></p><p>开发(模板3)+测试(模板3)+预发(模板5)+生产(模板5)</p><p><strong>3 ParNew+CMS垃圾回收器模板</strong></p><p><strong>模板1:Pod:CPU request:256m limit:2048m;内存 request:3584M limit 4096M ;弹性伸缩 CPU:480%</strong></p><p>-Xms2560M -Xmx2560M -Xmn1920M -XX:MetaspaceSize&#x3D;256M -XX:MaxMetaspaceSize&#x3D;256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction&#x3D;92 -XX:+CMSScavengeBeforeRemark</p><p><strong>模板2:Pod:CPU request:256m limit:1024m;内存 request:1536M limit 2048M;弹性伸缩 CPU:240%(常规配置,limit*0.6的位置弹性)</strong></p><p>-Xms1024M -Xmx1024M -Xmn768M -XX:MetaspaceSize&#x3D;256M -XX:MaxMetaspaceSize&#x3D;256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction&#x3D;92 -XX:+CMSScavengeBeforeRemark</p><p><strong>模板3:Pod:CPU request:128m limit:512m;内存 request:768M limit 1024M;弹性伸缩 CPU:240%</strong></p><p>-Xms448M -Xmx448M -Xmn336M -XX:SurvivorRatio&#x3D;4 -XX:MetaspaceSize&#x3D;256M -XX:MaxMetaspaceSize&#x3D;256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction&#x3D;92 -XX:+CMSScavengeBeforeRemark</p><p><strong>模板4:Pod:CPU request:128m limit:512m;内存 request:640M limit 1024M;弹性伸缩 CPU:240%</strong></p><p>-Xms384M -Xmx384M -Xmn288M -XX:SurvivorRatio&#x3D;4 -XX:MetaspaceSize&#x3D;256M -XX:MaxMetaspaceSize&#x3D;256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction&#x3D;92 -XX:+CMSScavengeBeforeRemark</p><p><strong>模板5:Pod:CPU request:1024m limit:4096m;内存 request:6144M limit 8192M;弹性伸缩 CPU:240%</strong></p><p>-Xms6144M -Xmx6144M -Xmn4608M -XX:MetaspaceSize&#x3D;256M -XX:MaxMetaspaceSize&#x3D;256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction&#x3D;92 -XX:+CMSScavengeBeforeRemark</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql相关</title>
      <link href="/2022/08/15/mysql/"/>
      <url>/2022/08/15/mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MVVC"><a href="#1-MVVC" class="headerlink" title="1. MVVC"></a>1. MVVC</h2><blockquote><p>MVCC用于读已提交和可重复读级别的控制，主要通过undo log日志版本链和read view来实现</p></blockquote><p>每个字段隐藏两个字段： roll_pointer<code>和</code>trx_id</p><p>roll_pointer指向更新事务之前生成的undo log，undo log用于事务的回滚，保证事务的原子性。</p><p>trx_id就是最近一次更新数据的事务ID</p><p><strong>ReadView 重要概念：</strong></p><ol><li>m_ids，就是还未提交的事务id集合</li><li>low_limit_id，ReadView 生成时刻系统尚未分配的下一个事务 ID</li><li>up_limit_id，<strong>是 trx_list 列表中事务 ID 最小的 ID</strong></li><li>creator_trx_id，创建read view的事务ID，也就是自己的事务</li></ol><p><strong>ReadView原理：</strong></p><ol><li>如果trx_id&lt;up_limit_id，那么说明就是之前事务的数据，直接返回，也就对应了小明第一次开启事务查询的场景</li><li>如果trx_id&gt;low_limit_id，trx_id还在[up_limit_id，low_limit_id]范围之内，并且trx_id在m_ids中，就会根据roll_pointer去查找undo log日志链，找到之前版本的数据。</li><li>如果trx_id&#x3D;creator_trx_id，那么说明就是自己修改的，直接返回就好了，对应的就是自己去修改数据的场景</li></ol><p><strong>不同隔离级别创建ReadView</strong> </p><ol><li>读提交</li></ol><p>​       每次查询都会生成一次read view</p><ol><li>可重复读</li></ol><p>​       整个事务生成一次快照读，并且在第一次读取时</p><h2 id="2-mysql-事务"><a href="#2-mysql-事务" class="headerlink" title="2. mysql 事务"></a>2. mysql 事务</h2><ul><li>原子性 ： 要么都成功，要么都失败</li><li>一致性 ： 从一个状态转换另一个稳定状态</li><li>隔离性 : 事务之间互补影响</li><li>持久性 :  事务一旦提交就永久有效</li></ul><h3 id="2-1-事务实现"><a href="#2-1-事务实现" class="headerlink" title="2.1 事务实现"></a>2.1 事务实现</h3><p><img src="/../images/mysql/mysql%E4%BA%8B%E5%8A%A1.svg" alt="mysql事务"></p><p>redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p><h4 id="2-1-1-redo-log-重做日志"><a href="#2-1-1-redo-log-重做日志" class="headerlink" title="2.1.1 redo log 重做日志"></a>2.1.1 redo log 重做日志</h4><p>redo log 有两部分组成 redo log buffer ，redo log  file</p><p>redo log 写入流程：</p><ul><li><p>执行update操作。</p></li><li><p>先将原始数据从磁盘读取到内存，修改内存中的数据。</p></li><li><p>生成一条重做日志写入redo log buffer，记录数据被修改后的值。</p></li><li><p>当事务提交时，需要将redo log buffer中的内容刷新到redo log file。</p></li><li><p>事务提交后，也会将内存中修改数据的值写入磁盘。</p></li></ul><p><strong>redo log为什么可以实现事务的原子性和持久性？</strong></p><ul><li><p>原子性，是redo log记录了事务期间操作的物理日志，事务提交之前，并没有写入磁盘，保存在内存里，如果事务失败，数据库磁盘不会有影响，回滚掉事务内存部分即可。</p></li><li><p>持久性，redo log 会在事务提交时将日志存储到磁盘redo log file，保证日志的持久性。</p></li></ul><h3 id="2-1-2-事务隔离级别"><a href="#2-1-2-事务隔离级别" class="headerlink" title="2.1.2  事务隔离级别"></a>2.1.2  事务隔离级别</h3><p>READ-UNCOMMITTED: 读未提交</p><p>READ-COMMITTED：读以提交</p><p>REPEATABLE-READ：可重复读</p><p>SERIALIZABLE: 序列化</p><h2 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3. 执行流程"></a>3. 执行流程</h2><ol><li>客户端发送更新命令到MySQL服务器，经过处理连接、解析优化等步骤；</li><li>Server层向InnoDB存储引擎要id&#x3D;1的这条记录；</li><li>存储引擎先从缓存中查找这条记录，有的话直接返回，没有则从磁盘加载到缓存中然后返回；</li><li>Server层执行器修改这条记录的name字段值；</li><li>存储引擎更新修改到内存中；</li><li>存储引擎记录redo日志，并将状态设置为<code>prepare</code>状态；</li><li>存储引擎通知执行器，修改完毕，可以进行事务提交；</li><li>Server先写了个binlog；</li><li>Server提交事务；</li><li>存储引擎将redo日志中和当前事务相关的记录状态设置为<code>commit</code>状态。</li></ol><h2 id="4-调优"><a href="#4-调优" class="headerlink" title="4. 调优"></a>4. 调优</h2><h3 id="4-1-工具-Explain使用"><a href="#4-1-工具-Explain使用" class="headerlink" title="4.1 工具 Explain使用"></a>4.1 工具 Explain使用</h3><p>select： all-&gt;index-&gt;rang-&gt;ref-&gt;const   查询速度递增</p><h3 id="4-2-mysql-优化原则"><a href="#4-2-mysql-优化原则" class="headerlink" title="4.2 mysql 优化原则"></a>4.2 mysql 优化原则</h3><ul><li>最左匹配</li><li>避免回表，（覆盖索引）</li><li>索引下推 5.6</li><li>不为离散度低数据设置索引 如sex</li><li>随机无序的值不作为索引，如身份证号，UUID</li><li>为用于搜索，排序，分组字段建立索引</li><li>频繁更新字段不适合作为索引</li></ul><h3 id="4-3-大表如何删除数据"><a href="#4-3-大表如何删除数据" class="headerlink" title="4.3 大表如何删除数据"></a>4.3 大表如何删除数据</h3><ul><li>删除索引</li><li>删除数据</li><li>创建索引</li></ul><h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5.使用"></a>5.使用</h2><p><strong>create</strong> <strong>user</strong> ‘ua‘@’%’ identified <strong>by</strong> ‘pa’; 创建用户（ua）和密码（pa）</p><p><strong>grant</strong> <strong>all</strong> privileges <strong>on</strong> <em>.</em> <strong>to</strong> ‘ua‘@’%’ <strong>with</strong> <strong>grant</strong> option; 全局权限</p><blockquote><p>注意： 对于一个已经存在的连接，它的全局权限不受 grant 命令的影响</p></blockquote><p><strong>revoke</strong> <strong>all</strong> privileges <strong>on</strong> <em>.</em> <strong>from</strong> ‘ua‘@’%’; 收回权限</p><h3 id="5-1-Db权限"><a href="#5-1-Db权限" class="headerlink" title="5.1 Db权限"></a>5.1 Db权限</h3><p><strong>grant</strong> <strong>all</strong> privileges <strong>on</strong> db1.* <strong>to</strong> ‘ua‘@’%’ <strong>with</strong> <strong>grant</strong> option;</p><blockquote><p>grant 修改 db 权限的时候，是同时对磁盘和内存生效的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rocketMq事务消息实现</title>
      <link href="/2022/08/15/rocket%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"/>
      <url>/2022/08/15/rocket%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1.流程"></a>1.流程</h3><p>RocketMQ 4.3 开始支持事务</p><p><strong>(1)、正常事务消息的发送及提交</strong><br>a、生产者发送half消息到Broker服务端（半消息）；</p><p>半消息是一种特殊的消息类型，该状态的消息暂时不能被Consumer消费。当一条事务消息被成功投递到Broker上，但是Broker并没有接收到Producer发出的二次确认时，该事务消息就处于”暂时不可被消费”状态，该状态的事务消息被称为半消息。</p><p>b、Broker服务端将消息持久化之后，给生产者响应消息写入结果（ACK响应）；</p><p>c、生产者根据发送结果执行本地事务逻辑（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）；</p><p>d、生产者根据本地事务执行结果向Broker服务端提交二次确认（Commit 或是 Rollback），Broker服务端收到 Commit 状态则将半事务消息标记为可投递，订阅方最终将收到该消息；Broker服务端收到 Rollback 状态则删除半事务消息，订阅方将不会接收该消息；</p><p><strong>(2)、事务消息的补偿流程</strong><br>a、在网络闪断或者是应用重启的情况下，可能导致生产者发送的二次确认消息未能到达Broker服务端，经过固定时间后，Broker服务端将会对没有Commit&#x2F;Rollback的事务消息（pending状态的消息）进行“回查”；</p><p>b、生产者收到回查消息后，检查回查消息对应的本地事务执行的最终结果；</p><p>c、生产者根据本地事务状态，再次提交二次确认给Broker，然后Broker重新对半事务消息Commit或者Rollback；</p><p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p><p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p><ul><li><p>TransactionStatus.CommitTransaction：提交事务，它允许消费者消费此消息。</p></li><li><p>TransactionStatus.RollbackTransaction：回滚事务，它代表该消息将被删除，不允许被消费</p></li></ul><ul><li>TransactionStatus.Unknown：中间状态，它代表需要回查本地事务状态来决定是提交还是回滚事务。</li></ul><h3 id="2-事例"><a href="#2-事例" class="headerlink" title="2.事例"></a>2.事例</h3><h4 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h4><p>使用 <code>TransactionMQProducer</code>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">mport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line">import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line">import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line">import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line">import org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line">import java.util.List;</span><br><span class="line">public class TransactionProducer &#123;</span><br><span class="line">   public static void main(String[] args) throws MQClientException, InterruptedException &#123;</span><br><span class="line">       TransactionListener transactionListener = new TransactionListenerImpl();</span><br><span class="line">       TransactionMQProducer producer = new TransactionMQProducer(&quot;please_rename_unique_group_name&quot;);</span><br><span class="line">       ExecutorService executorService = new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2000), new ThreadFactory() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public Thread newThread(Runnable r) &#123;</span><br><span class="line">               Thread thread = new Thread(r);</span><br><span class="line">               thread.setName(&quot;client-transaction-msg-check-thread&quot;);</span><br><span class="line">               return thread;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       producer.setExecutorService(executorService);</span><br><span class="line">       producer.setTransactionListener(transactionListener);</span><br><span class="line">       producer.start();</span><br><span class="line">       String[] tags = new String[] &#123;&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;&#125;;</span><br><span class="line">       for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               Message msg =</span><br><span class="line">                   new Message(&quot;TopicTest1234&quot;, tags[i % tags.length], &quot;KEY&quot; + i,</span><br><span class="line">                       (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">               SendResult sendResult = producer.sendMessageInTransaction(msg, null);</span><br><span class="line">               System.out.printf(&quot;%s%n&quot;, sendResult);</span><br><span class="line">               Thread.sleep(10);</span><br><span class="line">           &#125; catch (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">           Thread.sleep(1000);</span><br><span class="line">       &#125;</span><br><span class="line">       producer.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现事务的监听接口"><a href="#实现事务的监听接口" class="headerlink" title="实现事务的监听接口"></a>实现事务的监听接口</h4><p>当发送半消息成功时，我们使用 <code>executeLocalTransaction</code> 方法来执行本地事务。它返回前一节中提到的三个事务状态之一。<code>checkLocalTransaction</code> 方法用于检查本地事务状态，并回应消息队列的检查请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionListenerImpl implements TransactionListener &#123;</span><br><span class="line">  private AtomicInteger transactionIndex = new AtomicInteger(0);</span><br><span class="line">  private ConcurrentHashMap&lt;String, Integer&gt; localTrans = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  /***</span><br><span class="line">  *** 执行成功half消息，执行本地事务</span><br><span class="line">  ****/</span><br><span class="line">  @Override</span><br><span class="line">  public LocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">      int value = transactionIndex.getAndIncrement();</span><br><span class="line">      int status = value % 3;</span><br><span class="line">      localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">      return LocalTransactionState.UNKNOW;</span><br><span class="line">  &#125;</span><br><span class="line">  /****</span><br><span class="line">  **** 会查本地消息状态</span><br><span class="line">  ****/</span><br><span class="line">  @Override</span><br><span class="line">  public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123;</span><br><span class="line">      Integer status = localTrans.get(msg.getTransactionId());</span><br><span class="line">      if (null != status) &#123;</span><br><span class="line">          switch (status) &#123;</span><br><span class="line">              case 0:</span><br><span class="line">                  return LocalTransactionState.UNKNOW;</span><br><span class="line">              case 1:</span><br><span class="line">                  return LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">              case 2:</span><br><span class="line">                  return LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h3><p>​     在RocketMQ事务消息的主要流程中，一阶段的消息如何对用户不可见。其中，事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的。那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后改变主题为<code>RMQ_SYS_TRANS_HALF_TOPIC</code>。由于消费组未订阅该主题，故消费端无法消费half类型的消息。</p><ul><li>如何实现事务回查？</li></ul><p>​       roker会启动一个消息回查的定时任务，定时从事务消息queue中读取所有待反查的消息。针对每个需要反查的半消息，Broker会给对应的Producer发一个要求执行事务状态反查的RPC请求。然后根据RPC返回响应中的反查结果，来决定这个半消息是需要提交还是回滚，或者后续继续来反查。最后，提交或者回滚事务，将半消息标记为已处理状态【将消息存储在主题为：RMQ_SYS_TRANS_OP_HALF_TOPIC的主题中，代表这些消息已经被处理（提交或回滚）】。 如果是提交事务，就把半消息从半消息队列中复制到该消息真正的topic和queue中； 如果是回滚事务，则什么都不做。</p><h3 id="4-事务消息使用上的限制"><a href="#4-事务消息使用上的限制" class="headerlink" title="4. 事务消息使用上的限制"></a>4. 事务消息使用上的限制</h3><ol><li>事务消息不支持延时消息和批量消息。</li><li>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N &#x3D; <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionalMessageCheckListener</code> 类来修改这个行为。</li><li>事务消息将在 Broker 配置文件中的参数 transactionTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionTimeout</code> 参数。</li><li>事务性消息可能不止一次被检查或消费。</li><li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</li><li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</li></ol><p>参考 ： <a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#1%E5%88%9B%E5%BB%BA%E4%BA%8B%E5%8A%A1%E6%80%A7%E7%94%9F%E4%BA%A7%E8%80%85">rocket官方连接</a><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#1%E5%88%9B%E5%BB%BA%E4%BA%8B%E5%8A%A1%E6%80%A7%E7%94%9F%E4%BA%A7%E8%80%85">https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md#1%E5%88%9B%E5%BB%BA%E4%BA%8B%E5%8A%A1%E6%80%A7%E7%94%9F%E4%BA%A7%E8%80%85</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring为题总结</title>
      <link href="/2022/08/15/spring/"/>
      <url>/2022/08/15/spring/</url>
      
        <content type="html"><![CDATA[<h2 id="1-谈一谈spring-ioc理解？原理和实现"><a href="#1-谈一谈spring-ioc理解？原理和实现" class="headerlink" title="1. 谈一谈spring ioc理解？原理和实现"></a>1. 谈一谈spring ioc理解？原理和实现</h2><p>IOC ：控制反转， 对象一般都使用者创建，有了spring后把对象创建交给spring 容器.即</p><p>容器来负责控制对象的生命周期和对象间的关系</p><p>容器：存储对象，三级缓存 sigletionObjects ,earingsigletionObject ,sigletionFacotry</p><h2 id="2-bean的生命周期"><a href="#2-bean的生命周期" class="headerlink" title="2.bean的生命周期"></a>2.bean的生命周期</h2><blockquote><p> 创建实例-&gt;填充属性-&gt;初始化-&gt;使用-&gt;销毁</p></blockquote><ul><li>加载解析bean为beanDefinition</li><li>通过反射实例化具体对象 </li><li>填充属性 ： populateBean(),循环依赖</li><li>调用aware方法： 设置 BeanName ,BeanFactory </li><li>初始化 调用BeanPostProcessor</li></ul><p><img src="/../images/spring/spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="spring生命周期"></p><h2 id="3-Spring是如何解决的循环依赖？"><a href="#3-Spring是如何解决的循环依赖？" class="headerlink" title="3.Spring是如何解决的循环依赖？"></a>3.Spring是如何解决的循环依赖？</h2><p>   Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（singletonObjects）,二级缓存为早期曝光对象earlySingletonObjects，三级缓存为早期曝光对象工厂（singletonFactories）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p><h2 id="4-为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？"><a href="#4-为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？" class="headerlink" title="4.为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？"></a>4.为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？</h2><p>​    如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud 组件介绍</title>
      <link href="/2022/08/15/springCloud/"/>
      <url>/2022/08/15/springCloud/</url>
      
        <content type="html"><![CDATA[<h1 id="1-openFeign"><a href="#1-openFeign" class="headerlink" title="1.  openFeign"></a>1.  openFeign</h1><p> 为了保持向后兼容性，将用作默认负载平衡器实现。然而，Spring Cloud Netflix Ribbon现在处于维护模式，因此我们建议改用Spring Cloud LoadBalancer。为此，将spring.cloud.looadbalancer.ribbon.enabled的值设置为false。</p><h2 id="1-1-覆盖默认配置"><a href="#1-1-覆盖默认配置" class="headerlink" title="1.1 覆盖默认配置"></a>1.1 覆盖默认配置</h2><p>​    默认Spring Cloud使用Spring Cloud使用FeignClientsConfiguration按需为每个命名的客户端创建一个新的集成作为ApplicationContext。这包含（除其他外）一个foreign.Decorder、一个foregn.Encoder和一个feign.Contract。可以使用@FeignClient注释的contextId属性重写该集合的名称按需为每个命名的客户端创建一个新的集成作为ApplicationContext。这包含（除其他外）一个foreign.Decorder、一个foregn.Encoder和一个feign.Contract。可以使用@FeignClient注释的contextId属性重写该集合的名称</p><p>覆盖默认配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;stores&quot;, configuration = FooConfiguration.class)</span><br><span class="line">public interface StoreClient &#123;</span><br><span class="line">    //..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注： FooConfiguration.class  不需要  <code>@Configuration</code>,否者会替换全局默认配置</p><p>占位符方式支持 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;$&#123;feign.name:chen&#125;&quot;, url = &quot;$&#123;feign.url&#125;&quot;)</span><br><span class="line">public interface StoreClient &#123;</span><br><span class="line">    //..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring cloud 默认feign配置：</p><ul><li><code>Decoder</code> feignDecoder: <code>ResponseEntityDecoder</code> (which wraps a <code>SpringDecoder</code>)</li><li><code>Encoder</code> feignEncoder: <code>SpringEncoder</code></li><li><code>Logger</code> feignLogger: <code>Slf4jLogger</code></li><li><code>Contract</code> feignContract: <code>SpringMvcContract</code></li><li><code>Feign.Builder</code> feignBuilder: <code>HystrixFeign.Builder</code></li></ul><ul><li><p>if Ribbon is in the classpath and is enabled it is a <code>LoadBalancerFeignClient</code>, otherwise if Spring Cloud LoadBalancer is in the classpath, <code>FeignBlockingLoadBalancerClient</code> is used. If none of them is in the classpath, the default feign client is used.</p><p> feign.okhttp.enabled： true 支持okHttp</p><p> feign.httpclient.enabled: true 支持httpClient</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FooConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Contract feignContract() &#123;</span><br><span class="line">        return new feign.Contract.Default();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public BasicAuthRequestInterceptor basicAuthRequestInterceptor() &#123;</span><br><span class="line">        return new BasicAuthRequestInterceptor(&quot;user&quot;, &quot;password&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>feign.Contract.Default</code>代替FeignClientsConfiguration中的contract 并添加 <code>RequestInterceptor</code>到 <code>RequestInterceptor</code>集合</p><p>也可以用配置文件覆盖：</p><p>application.yaml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      contextId:</span><br><span class="line">        connectTimeout: 5000</span><br><span class="line">        readTimeout: 5000</span><br><span class="line">        loggerLevel: full</span><br><span class="line">        errorDecoder: com.example.SimpleErrorDecoder</span><br><span class="line">        retryer: com.example.SimpleRetryer</span><br><span class="line">        requestInterceptors:</span><br><span class="line">          - com.example.FooRequestInterceptor</span><br><span class="line">          - com.example.BarRequestInterceptor</span><br><span class="line">        decode404: false</span><br><span class="line">        encoder: com.example.SimpleEncoder</span><br><span class="line">        decoder: com.example.SimpleDecoder</span><br><span class="line">        contract: com.example.SimpleContract</span><br></pre></td></tr></table></figure><p>contentId：未设置时通name相等</p><p><img src="/../images/springcloud/feign/feign%E8%B0%83%E7%94%A8content.png" alt="image-20230113173432411"></p><p>对所有feign生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      default:</span><br><span class="line">        connectTimeout: 5000</span><br><span class="line">        readTimeout: 5000</span><br><span class="line">        loggerLevel: basic</span><br></pre></td></tr></table></figure><p>默认配置文件优先于@Configuration， 你可以通过feign.client.default-to-properties设置false 改变优先级</p><p>另外：如果需要在RequestInterceptor中使用ThreadLocal绑定变量，则需要将Hystrix的线程隔离策略设置为“SEMAPHORE”或在Feign中禁用Hystrix。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># To disable Hystrix in Feign</span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: false</span><br><span class="line"></span><br><span class="line"># To set thread isolation to SEMAPHORE</span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    default:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          strategy: SEMAPHORE</span><br></pre></td></tr></table></figure><p>   如果我们希望创建多个具有相同名称或url的外部客户端，以便它们指向相同的服务器，但每个客户端具有不同的自定义配置，那么我们必须使用@FeignClient的contextId属性，以避免这些配置bean的名称冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(contextId = &quot;fooClient&quot;, name = &quot;stores&quot;, configuration = FooConfiguration.class)</span><br><span class="line">public interface FooClient &#123;</span><br><span class="line">    //..</span><br><span class="line">&#125;</span><br><span class="line">@FeignClient(contextId = &quot;barClient&quot;, name = &quot;stores&quot;, configuration = BarConfiguration.class)</span><br><span class="line">public interface BarClient &#123;</span><br><span class="line">    //..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hystrix 存在于类路径上，并且 foreign.Hystrix.enabled&#x3D;true，支持熔断</p><p>所有不支持hystrix ： 创建一个原型的Feign.Builder</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FooConfiguration &#123;</span><br><span class="line">        @Bean</span><br><span class="line">    @Scope(&quot;prototype&quot;)</span><br><span class="line">    public Feign.Builder feignBuilder() &#123;</span><br><span class="line">        return Feign.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-日志级别"><a href="#1-2-日志级别" class="headerlink" title="1.2 日志级别"></a>1.2 日志级别</h2><p>配置类单独定义日志级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(contextId = &quot;fooClient&quot;, name = &quot;stores&quot;, configuration = FooConfiguration.class)</span><br><span class="line">public interface FooClient &#123;</span><br><span class="line">    //..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FooConfiguration&#123;</span><br><span class="line"></span><br><span class="line">@Bean </span><br><span class="line">public Logger.Level  level()&#123;</span><br><span class="line">  return Logger.Level.FULL();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 配置文件方式 （优先级高于代码配置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(contentId=&quot;stores1&quot; name = &quot;stores&quot;)</span><br><span class="line">public interface FooClient &#123;</span><br><span class="line">    //..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      stores1:</span><br><span class="line">        logLevel: full</span><br></pre></td></tr></table></figure><h2 id="1-3-feign支持配置项"><a href="#1-3-feign支持配置项" class="headerlink" title="1.3 feign支持配置项"></a>1.3 feign支持配置项</h2><p>配置文件方式：</p><p><img src="/../images/springcloud/feign/feign%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE.png" alt="image-20230116142927928"></p><h1 id="2-ribbon"><a href="#2-ribbon" class="headerlink" title="2.ribbon"></a>2.ribbon</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@RibbonClient(name = &quot;custom&quot;, configuration = CustomConfiguration.class)</span><br><span class="line">public class TestConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CustomConfiguration</code> 不需要用 <code>@Configuration</code> 注解修饰, 并且不能被@ComponentScan<code>在 application context 环境扫描到.否则 将被所有</code>@RibbonClients  共用，如果你用了<code>@ComponentScan</code> (or <code>@SpringBootApplication</code>),你需要把这个配置排除在外。</p><p>默认ribbon配置：</p><table><thead><tr><th align="center">Bean Type</th><th align="center">Bean Name</th><th align="center">Class Name</th></tr></thead><tbody><tr><td align="center"><code>IClientConfig</code></td><td align="center"><code>ribbonClientConfig</code></td><td align="center"><code>DefaultClientConfigImpl</code></td></tr><tr><td align="center"><code>IRule</code></td><td align="center"><code>ribbonRule</code></td><td align="center"><code>ZoneAvoidanceRule</code></td></tr><tr><td align="center"><code>IPing</code></td><td align="center"><code>ribbonPing</code></td><td align="center"><code>DummyPing</code></td></tr><tr><td align="center"><code>ServerList&lt;Server&gt;</code></td><td align="center"><code>ribbonServerList</code></td><td align="center"><code>ConfigurationBasedServerList</code></td></tr><tr><td align="center"><code>ServerListFilter&lt;Server&gt;</code></td><td align="center"><code>ribbonServerListFilter</code></td><td align="center"><code>ZonePreferenceServerListFilter</code></td></tr><tr><td align="center"><code>ILoadBalancer</code></td><td align="center"><code>ribbonLoadBalancer</code></td><td align="center"><code>ZoneAwareLoadBalancer</code></td></tr><tr><td align="center"><code>ServerListUpdater</code></td><td align="center"><code>ribbonServerListUpdater</code></td><td align="center"><code>PollingServerListUpdater</code></td></tr></tbody></table><h2 id="2-2-自定义默认全局配置"><a href="#2-2-自定义默认全局配置" class="headerlink" title="2.2 自定义默认全局配置"></a>2.2 自定义默认全局配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@RibbonClients(defaultConfiguration = DefaultRibbonConfig.class)</span><br><span class="line">public class RibbonClientDefaultConfigurationTestsConfig &#123;</span><br><span class="line"></span><br><span class="line">    public static class BazServiceList extends ConfigurationBasedServerList &#123;</span><br><span class="line"></span><br><span class="line">        public BazServiceList(IClientConfig config) &#123;</span><br><span class="line">            super.initWithNiwsConfig(config);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">class DefaultRibbonConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public IRule ribbonRule() &#123;</span><br><span class="line">        return new BestAvailableRule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public IPing ribbonPing() &#123;</span><br><span class="line">        return new PingUrl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServerList&lt;Server&gt; ribbonServerList(IClientConfig config) &#123;</span><br><span class="line">        return new RibbonClientDefaultConfigurationTestsConfig.BazServiceList(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServerListSubsetFilter serverListFilter() &#123;</span><br><span class="line">        ServerListSubsetFilter filter = new ServerListSubsetFilter();</span><br><span class="line">        return filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-自定义client配置通过属性配置"><a href="#2-3-自定义client配置通过属性配置" class="headerlink" title="2.3 自定义client配置通过属性配置"></a>2.3 自定义client配置通过属性配置</h2><ul><li><p><code>&lt;clientName&gt;.ribbon.NFLoadBalancerClassName</code>: Should implement <code>ILoadBalancer</code></p></li><li><p><code>&lt;clientName&gt;.ribbon.NFLoadBalancerRuleClassName</code>: Should implement <code>IRule</code></p></li><li><p><code>&lt;clientName&gt;.ribbon.NFLoadBalancerPingClassName</code>: Should implement <code>IPing</code></p></li><li><p><code>&lt;clientName&gt;.ribbon.NIWSServerListClassName</code>: Should implement <code>ServerList</code></p></li><li><p><code>&lt;clientName&gt;.ribbon.NIWSServerListFilterClassName</code>: Should implement <code>ServerListFilter</code></p><p> 属性配置，优先于代码配置</p></li></ul><h2 id="2-4-直接使用api"><a href="#2-4-直接使用api" class="headerlink" title="2.4 直接使用api"></a>2.4 直接使用api</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">    public void doStuff() &#123;</span><br><span class="line">        ServiceInstance instance = loadBalancer.choose(&quot;stores&quot;);</span><br><span class="line">        URI storesUri = URI.create(String.format(&quot;https://%s:%s&quot;, instance.getHost(), instance.getPort()));</span><br><span class="line">        // ... do something with the URI</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-缓存ribbon配置"><a href="#2-5-缓存ribbon配置" class="headerlink" title="2.5 缓存ribbon配置"></a>2.5 缓存ribbon配置</h2><p>​    每个Ribbon命名的客户端都有一个Spring Cloud维护的相应子应用程序上下文。该应用程序上下文在第一次请求命名客户端时被延迟加载。通过指定Ribbon客户端的名称，可以更改这种延迟加载行为，以在启动时急切地加载这些子应用程序上下文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: true</span><br><span class="line">    clients: client1, client2, client3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring事务机制</title>
      <link href="/2022/08/15/spring%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/08/15/spring%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="spring-事务"><a href="#spring-事务" class="headerlink" title="spring 事务"></a>spring 事务</h2><h2 id="1-事务传播机制"><a href="#1-事务传播机制" class="headerlink" title="1. 事务传播机制"></a>1. 事务传播机制</h2><ul><li><p>REQUIRED ： 如果当前没有事务，新建事务执行，存在事务，加入事务中运行</p></li><li><p>SUPPORTS :   支持当前事务。 如果当前存在事务，则加入事务，否则以非事务方式运行</p></li><li><p>MANDATORY :  强制要求事务，使用当前事务，如果没有抛出异常</p></li><li><p>NO_SUPPORTED: 不支持当前事务，如果存在事务，把事务挂起以非事务方式运行。</p></li><li><p>REQUIRED_NEW：需要事务，创建一个新的事务</p></li><li><p>NEVER:  不需要事务，当前存在事务，抛异常</p></li><li><p>NESTED : 如果当前存在事务，则在嵌套事务运行，否则新建事务</p></li></ul><p><img src="/../images/image-20211101180144232.png" alt="image-20221212095037158"></p><p><code>REQUIRED</code> 和 <code>NESTED</code> 区别：</p><p>两个方法都加了事务注解，并且两个方法都会受到到事务管理的拦截器增强，并且事务传播的方式都是默认的，也就是<code>REQUIRED</code>，当已经存在事务的时候就加入事务，没有就创建事务。这里A和B都受事务控制，并且是处于同一个事务的。</p><p>A调用B，A中抓了B的异常，当B发生异常的时候，B的操作应该回滚，但是A吃了异常，A方法中没有产生异常，所以A的操作又应该提交，二者是相互矛盾的。</p><p>spring的事务关联拦截器在抓到B的异常后就会标记<code>rollback-only</code>为<code>true</code>，当A执行完准备提交后，发现<code>rollback-only</code>为<code>true</code>，也会回滚，并抛出异常告诉调用者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation=Propagation.REQUIRED)</span><br><span class="line">a()&#123;</span><br><span class="line">       a插入数据库;</span><br><span class="line">    try &#123;</span><br><span class="line">            b();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">@Transactional(propagation=Propagation.NESTED)</span><br><span class="line">b()&#123;</span><br><span class="line">    b插入数据库;</span><br><span class="line">   int xx=1/0;//抛出异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码 则只有b的插入回滚，a不回滚。原因是在进入NESTED方法时事务保存了当前b的<code>savepoint</code>，b异常只会回滚到b的<code>savepoint</code></p><p>同时若在a方法中抛出异常，则a,b插入都会回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation=Propagation.REQUIRED)</span><br><span class="line">a()&#123;</span><br><span class="line">       a插入数据库;</span><br><span class="line">    try &#123;</span><br><span class="line">            b();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   int xx=1/0;//抛出异常</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">@Transactional(propagation=Propagation.NESTED)</span><br><span class="line">b()&#123;</span><br><span class="line">    b插入数据库;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NESTED嵌套事务的奥秘之处—–它能让事务部分回滚</strong>(通过<code>savepoint</code>)</p><p><strong>NESTED的回滚特性</strong></p><ul><li>主事务和嵌套事务属于同一个事务</li><li>嵌套事务出错回滚不会影响到主事务</li><li>主事务回滚会将嵌套事务一起回滚了</li></ul><p>NESTED事务跟REQUIRED事务区别就在这里，NESTED事务是回滚到回滚点，而回滚点生成是在进入内嵌事务的时候，外面事务是不会回滚的</p><h2 id="2-声明式事务不生效原因"><a href="#2-声明式事务不生效原因" class="headerlink" title="2. 声明式事务不生效原因"></a>2. 声明式事务不生效原因</h2><ol><li><p>数据库不支持事务</p></li><li><p>抛出检查下异常</p></li><li><p>方法内调用事务方法</p></li><li><p>创建类不接受spring管理</p></li><li><p>@Transaction修饰方法不是public</p></li><li><p>捕获了异常，未抛出</p></li></ol><ol start="7"><li>配置多了事务管理器 如Mongo和mysql</li></ol><p>方法内互相调用失效问题： 绕过代理对象，事务使用代理对象来控制的，解决使用aspectj</p><ul><li><p>引入<code> aop-start; spring-boot-start-aop</code></p></li><li><p>开启 <code>@EnableAspectJautoProxy</code></p><p><code>AopContext.currentProxy()</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring boot 自动装配自动原理</title>
      <link href="/2022/08/15/springboot/"/>
      <url>/2022/08/15/springboot/</url>
      
        <content type="html"><![CDATA[<h2 id="1-自动装配原理"><a href="#1-自动装配原理" class="headerlink" title="1. 自动装配原理"></a>1. 自动装配原理</h2><p><img src="/../images/spring/spring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.png" alt="spring自动装配"></p><h2 id="2-spring常见"><a href="#2-spring常见" class="headerlink" title="2.spring常见"></a>2.spring常见</h2><h3 id="1-bean实例化流程"><a href="#1-bean实例化流程" class="headerlink" title="1. bean实例化流程"></a>1. bean实例化流程</h3><p> 扫描class –&gt; BeanDefinition –&gt; 推断构造方法 –&gt; 实例化 –&gt; 原始对象 –&gt; 填充属性  –&gt; Aware相关接口处理 –&gt; BeanPostProcessor前置处理 –&gt; 初始化 –&gt; BeanPostProcessor后置处理 –&gt; (AOP –&gt; userService代理对象) –&gt; bean</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tomcat架构</title>
      <link href="/2022/08/15/tomcat/"/>
      <url>/2022/08/15/tomcat/</url>
      
        <content type="html"><![CDATA[<h2 id="1-tomcat-架构-整体架构"><a href="#1-tomcat-架构-整体架构" class="headerlink" title="1.tomcat 架构 整体架构"></a>1.tomcat 架构 整体架构</h2><p>（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；<br>（2） Server掌管着整个Tomcat的生死大权；<br>（4）Service 是对外提供服务的；<br>（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；<br>（6）Container用于封装和管理Servlet，以及具体处理request请求；</p><h2 id="2-Connector架构"><a href="#2-Connector架构" class="headerlink" title="2.Connector架构"></a>2.Connector架构</h2><p><img src="/../images/tomcat/tomcat%E6%9E%B6%E6%9E%84.svg" alt="tomcat"></p><blockquote><p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的</p></blockquote><p>ProtocolHandler 包含三部分：EndPoint，Processor, Adapter</p><ul><li>EndPoint用于处理底层的socket的网络连接，封装成Request，Adapter用于将Requet 交给Container</li><li>EndPoint 处理底层socket连接，因此实现TCP&#x2F;IP协议，Processor 实现了 Http协议</li><li>Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理</li></ul><h2 id="3-Container架构"><a href="#3-Container架构" class="headerlink" title="3. Container架构"></a>3. Container架构</h2><p><img src="/../images/tomcat/Container%E6%9E%B6%E6%9E%842.svg" alt="Container架构"></p><p>Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine</p><p>host: 每个host代表一个虚拟主机</p><p>context: 每个context 代表一个应用</p><p>wrapper: 每个wrapper 代表一个servlet</p><h2 id="4-container-如何处理请求"><a href="#4-container-如何处理请求" class="headerlink" title="4.container 如何处理请求"></a>4.container 如何处理请求</h2><blockquote><p>Container处理请求是使用Pipeline-Value管道来处理的</p></blockquote><p>Container包含四个子容器，而这四个子容器对应的BaseValue分别在：StandardEngineValue、StandardHostValue、StandardContextValue、StandardWrapperValue</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幂等</title>
      <link href="/2022/08/15/%E5%B9%82%E7%AD%89/"/>
      <url>/2022/08/15/%E5%B9%82%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-token-机制"><a href="#1-token-机制" class="headerlink" title="1.token 机制"></a>1.token 机制</h2><h2 id="2-各种锁"><a href="#2-各种锁" class="headerlink" title="2. 各种锁"></a>2. 各种锁</h2><ul><li>数据库悲观锁</li><li>数据库乐观锁</li><li>业务分布式锁</li></ul><h2 id="3-各种唯一约束"><a href="#3-各种唯一约束" class="headerlink" title="3. 各种唯一约束"></a>3. 各种唯一约束</h2><ul><li>数据库唯一约束</li><li>redis set 防重</li></ul><h2 id="4-防重表"><a href="#4-防重表" class="headerlink" title="4. 防重表"></a>4. 防重表</h2><h2 id="5-全局唯一id"><a href="#5-全局唯一id" class="headerlink" title="5. 全局唯一id"></a>5. 全局唯一id</h2>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2022/08/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/08/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="XA-协议"><a href="#XA-协议" class="headerlink" title="XA 协议"></a>XA 协议</h2><p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png" alt="image-20221208154800591"></p><p><code>XA</code>协议是使用了二阶段协议的，其中：</p><ul><li>第一阶段TM要求所有的RM准备提交对应的事务分支，询问RM是否有能力保证成功的提交事务分支，RM根据自己的情况，如果判断自己进行的工作可以被提交，那就就对工作内容进行持久化，并给TM回执OK；否者给TM的回执NO。RM在发送了否定答复并回滚了已经的工作后，就可以丢弃这个事务分支信息了。</li><li>第二阶段TM根据阶段1各个RM prepare的结果，决定是提交还是回滚事务。如果所有的RM都prepare成功，那么TM通知所有的RM进行提交；如果有RM prepare回执NO的话，则TM通知所有RM回滚自己的事务分支。</li></ul><p>方案缺点：</p><p> 该方案的缺陷：</p><p>​     同步阻塞：所有的参与者都是事务同步阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。<br>单点故障：一旦协调器发生故障，系统不可用。<br>数据不一致：当协调器发送commit之后，有的参与者收到commit消息，事务执行成功，有的没有收到，处于阻塞状态，这段时间会产生数据不一致性。<br>不确定性：当协调器发送commit之后，并且此时只有一个参与者收到了commit，那么当该参与者与协调器同时宕机之后，重新选举的协调器无法确定该条消息是否提交成功。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul><li>事务参与者 </li><li>事务协调者</li><li>资源管理器 RM</li><li>事务管理器 TM</li></ul><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h4 id="1-2Pc-和-3PC"><a href="#1-2Pc-和-3PC" class="headerlink" title="1. 2Pc 和 3PC"></a>1. <code>2Pc</code> 和 <code>3PC</code></h4><p><code>2PC</code>过程</p><p> 1）准备阶段：事务协调者向各个事务参与者发起询问请求：“我要执行全局事务了，这个事务涉及到的资源分布在你们这些数据源中，分别是……，你们准备好各自的资源（即各自执行本地事务到待提交阶段）”。各个参与者协调者回复 yes（表示已准备好，允许提交全局事务）或 no（表示本参与者无法拿到全局事务所需的本地资源，因为它被其他本地事务锁住了）或超时。</p><p>2）提交阶段：如果各个参与者回复的都是 yes，则协调者向所有参与者发起事务提交操作，然后所有参与者收到后各自执行本地事务提交操作并向协调者发送 <code>ACK</code>；如果任何一个参与者回复 no 或者超时，则协调者向所有参与者发起事务回滚操作，然后所有参与者收到后各自执行本地事务回滚操作并向协调者发送 <code>ACK</code>。</p><p><code>2PC存在问题</code></p><p>1）性能差，在准备阶段，要等待所有的参与者返回，才能进入阶段二，在这期间，各个参与者上面的相关资源被排他地锁住，参与者上面意图使用这些资源的本地事务只能等待。因为存在这种同步阻塞问题，所以影响了各个参与者的本地事务并发度</p><p>2）准备阶段完成后，如果协调者宕机，所有的参与者都收不到提交或回滚指令，导致所有参与者“不知所措”</p><p>3）在提交阶段，协调者向所有的参与者发送了提交指令，如果一个参与者未返回 <code>ACK</code>，那么协调者不知道这个参与者内部发生了什么（由于网络二将军问题的存在，这个参与者可能根本没收到提交指令，一直处于等待接收提交指令的状态；也可能收到了，并成功执行了本地提交，但返回的 <code>ACK</code> 由于网络故障未送到协调者上），也就无法决定下一步是否进行全体参与者的回滚。</p><p>4） 使用参与者实现<code>XA</code>协议</p><p><code>3pc</code> : 询问阶段、准备阶段、提交或回滚阶段 ,参与者加入超时机制，解决<code>2pc</code>同步阻塞问题和避免资源被永久锁定</p><ol><li><p><code>CanCommit</code></p></li><li><p><code>PreCommit</code></p></li><li><p><code>do Commit</code></p></li></ol><h4 id="2-TCC"><a href="#2-TCC" class="headerlink" title="2. TCC"></a>2. <code>TCC</code></h4><p> 1）阶段一：准备阶段。协调者调用所有的每个微服务提供的 try 接口，将整个全局事务涉及到的资源锁定住，若锁定成功 try 接口向协调者返回 yes。</p><p>2）阶段二：提交阶段。若所有的服务的 try 接口在阶段一都返回 yes，则进入提交阶段，协调者调用所有服务的 confirm 接口，各个服务进行事务提交。如果有任何一个服务的 try 接口在阶段一返回 no 或者超时，则协调者调用所有服务的 cancel 接口。</p><p>失败重试，接口幂等</p><p>接口幂等方案： 每个参与者可以维护一个去重表（可以利用数据库表实现也可以使用内存型 KV 组件实现），记录每个全局事务（以全局事务标<code> XID</code> 区分）是否进行过 confirm 或 cancel 操作，若已经进行过，则不再重复执行。</p><h4 id="3-事务状态表方案"><a href="#3-事务状态表方案" class="headerlink" title="3.事务状态表方案"></a>3.事务状态表方案</h4><p>假设要在一个分布式事务中实现调用<code>repo-service</code>扣减库存、调用 order-service 生成订单两个过程。在这种方案中，协调者 shopping-service 维护一张如下的事务状态表：</p><table><thead><tr><th align="left">分布式事务 ID</th><th align="left">事务内容</th><th align="left">事务状态</th></tr></thead><tbody><tr><td align="left"><code>global_trx_id_1</code></td><td align="left">操作 1：调用 <code>repo-service</code> 扣减库存 操作 2：调用 order-service 生成订单</td><td align="left">状态 1：初始 状态 2：操作 1 成功 状态 3：操作 1、2 成功</td></tr></tbody></table><p>初始状态为 1，每成功调用一个服务则更新一次状态，最后所有的服务调用成功，状态更新到 3。</p><p>有了这张表，就可以启动一个后台任务，扫描这张表中事务的状态，如果一个分布式事务一直（设置一个事务周期阈值）未到状态 3，说明这条事务没有成功执行，于是可以重新调用<code> repo-service</code> 扣减库存、调用 order-service 生成订单。直至所有的调用成功，事务状态到 3。</p><p>如果多次重试仍未使得状态到 3，可以将事务状态置为 error，通过人工介入进行干预。</p><h4 id="4-基于消息中间件的最终一致性事务方案"><a href="#4-基于消息中间件的最终一致性事务方案" class="headerlink" title="4 .基于消息中间件的最终一致性事务方案"></a>4 .基于消息中间件的最终一致性事务方案</h4><p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6.png" alt="image-20221207174330304"></p><p> 一种是基于<code>MQ</code>的事务消息</p><p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/mq%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png" alt="image-20221208141934124"></p><p> <code>RocketMQ</code>在4.3.0版中已经支持分布式事务消息，采用了<code>2PC</code>（两阶段提交）+ 补偿机制（事务状态回查）的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息</p><p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/RocketMq%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.png" alt="image-20221208145741982"></p><h2 id="开源分布式事务框架-Seata-的实现"><a href="#开源分布式事务框架-Seata-的实现" class="headerlink" title="开源分布式事务框架 Seata 的实现"></a>开源分布式事务框架 <code>Seata</code> 的实现</h2><h3 id="1-Seata包含以下几个核心组件"><a href="#1-Seata包含以下几个核心组件" class="headerlink" title="1.Seata包含以下几个核心组件"></a>1.<code>Seata</code>包含以下几个核心组件</h3><ul><li>Transaction Coordinator（TC）：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。</li><li>Transaction Manager（TM）：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。</li><li>Resource Manager（RM）：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。</li></ul><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><p> <strong>整体流程</strong></p><ol><li>事务开启时，TM向TC注册全局事务，并且获得全局事务<code>XID</code></li><li>这时候多个微服务的接口发生调用，<code>XID</code>就会传播到各个微服务中，每个微服务执行事务也会向TC注册分支事务。</li><li>之后TM就可以管理针对每个<code>XID</code>的事务全局提交和回滚，RM完成分支的提交或者回滚。</li></ol><p>  <strong>AT模式</strong></p><ol><li>TM向TC注册全局事务，获得<code>XID</code></li><li>RM则会去代理<code>JDBC</code>数据源，生成镜像的<code>SQL</code>，形成UNDO_LOG，然后向TC注册分支事务，把数据更新和UNDO_LOG在本地事务中一起提交</li><li>TC如果收到commit请求，则会异步去删除对应分支的UNDO_LOG，如果是rollback，就去查询对应分支的UNDO_LOG，通过UNDO_LOG来执行回滚</li></ol><p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/Seate-AT.png" alt="image-20221216161629827"></p><p><strong><code>TCC</code>模式</strong></p><p>相比AT模式代理<code>JDBC</code>数据源生成UNDO_LOG来生成逆向<code>SQL</code>回滚的方式，<code>TCC</code>就更简单一点了。</p><ol><li>TM向TC注册全局事务，获得<code>XID</code></li><li>RM向TC注册分支事务，然后执行Try方法，同时上报Try方法执行情况</li><li>然后如果收到TC的commit请求就执行Confirm方法，收到rollback则执行Cancel</li></ol><p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/Seta-TCC.png" alt="image-20221216162828209"></p><p><strong><code>XA</code>模式</strong></p><ol><li>TM向TC注册全局事务，获得<code>XID</code></li><li>RM向TC注册分支事务，<code>XA</code> Start，执行<code>SQL</code>，<code>XA END</code>，<code>XA Prepare</code>，然后上报分支执行情况</li><li>然后如果收到TC的commit请求就执行Confirm方法，收到rollback则执行Cancel</li></ol><p>  <img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/XA.png" alt="image-20221216163027941"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2022/08/15/%E5%8D%95%E4%BE%8B/"/>
      <url>/2022/08/15/%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-饿汉"><a href="#1-饿汉" class="headerlink" title="1. 饿汉"></a>1. 饿汉</h2><h2 id="2-懒汉"><a href="#2-懒汉" class="headerlink" title="2 .懒汉"></a>2 .懒汉</h2><p>双重检验： <code>volatitle</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletionObject</span>&#123;</span><br><span class="line"></span><br><span class="line">priviate volatitle SingletionObject signletionObject;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">getSignletionObject</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(signletionObject==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(SingletionObject.class)&#123;</span><br><span class="line">    <span class="keyword">if</span>(signletionObject==<span class="literal">null</span>)&#123;</span><br><span class="line">      signletionObject= <span class="keyword">new</span> <span class="title class_">SingletionObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="keyword">return</span> signletionObject;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么用<code>volatitle</code>:</p><p>new 对象分三步操作： 2,3指令重排</p><ol><li>分配对象内存</li><li>调用构造器方法，执行初始化</li><li>将对象引用赋值给变量。</li></ol><h2 id="3-枚举或者静态内部类"><a href="#3-枚举或者静态内部类" class="headerlink" title="3. 枚举或者静态内部类"></a>3. 枚举或者静态内部类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class StaticSingleton &#123;</span><br><span class="line"></span><br><span class="line">private StaticSingleton() &#123; /*……*/&#125;</span><br><span class="line"></span><br><span class="line">private static class SingletonHolder &#123;</span><br><span class="line">private static StaticSingleton instance = new StaticSingleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static StaticSingleton getInstance() &#123;</span><br><span class="line">return SingletonHolder.instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 匿名内部类支持延迟加载， 枚举不能通过 构造，反序列化，克隆等破坏</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存一致性</title>
      <link href="/2022/08/15/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/08/15/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-mysql-和redis-缓存一致性问题"><a href="#1-mysql-和redis-缓存一致性问题" class="headerlink" title="1.mysql 和redis 缓存一致性问题"></a>1.mysql 和redis 缓存一致性问题</h2><h3 id="1-1-先写数据库后删除缓存"><a href="#1-1-先写数据库后删除缓存" class="headerlink" title="1.1 先写数据库后删除缓存"></a>1.1 先写数据库后删除缓存</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网关设计</title>
      <link href="/2022/08/15/%E7%BD%91%E5%85%B3/"/>
      <url>/2022/08/15/%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-为什么需要网关"><a href="#1-为什么需要网关" class="headerlink" title="1.为什么需要网关"></a>1.为什么需要网关</h2><ul><li>协议装换，统一入口</li><li>统一鉴权</li></ul><h2 id="2-网关设计"><a href="#2-网关设计" class="headerlink" title="2. 网关设计"></a>2. 网关设计</h2><ul><li>服务注册</li><li>请求路由</li><li>负载均衡</li><li>弹力设计（异步，重试，幂等，流控，熔断，降级）</li><li>安全方面 （<code>ssl</code>加密证书管理，session验证授权，灰度发布）</li><li><code>api</code>聚合</li><li><code>api</code>编排</li></ul><h2 id="3-网关设计目标"><a href="#3-网关设计目标" class="headerlink" title="3. 网关设计目标"></a>3. 网关设计目标</h2><h3 id="3-1-高性能"><a href="#3-1-高性能" class="headerlink" title="3.1 高性能"></a>3.1 高性能</h3><ul><li>前端请求异步不阻塞<code>io</code>请求。</li></ul><h3 id="3-2-高可用"><a href="#3-2-高可用" class="headerlink" title="3.2 高可用"></a>3.2 高可用</h3><ul><li>集群化</li><li>服务化</li><li>持续化</li></ul><h3 id="3-3-高扩展"><a href="#3-3-高扩展" class="headerlink" title="3.3  高扩展"></a>3.3  高扩展</h3>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列</title>
      <link href="/2022/08/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2022/08/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-消息队列对比"><a href="#1-消息队列对比" class="headerlink" title="1. 消息队列对比"></a>1. 消息队列对比</h2><p><img src="/%5Cimages%5C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5C1.png" alt="img">  </p><h2 id="2-为什么Kafka不能支持更多的分区"><a href="#2-为什么Kafka不能支持更多的分区" class="headerlink" title="2. 为什么Kafka不能支持更多的分区?"></a>2. 为什么Kafka不能支持更多的分区?</h2><ul><li>分区内顺序写入，性能高，如果分区多，分区变多，操作系统看，写入变的随机</li></ul><h2 id="3-RocketMQ可以支持更多分区"><a href="#3-RocketMQ可以支持更多分区" class="headerlink" title="3. RocketMQ可以支持更多分区"></a>3. <code>RocketMQ</code>可以支持更多分区</h2><ol><li>所有消息数据都存储在提交日志文件中。所有写入都是完全顺序的，而读取是随机的。</li><li><code>ConsumeQueue</code>存储实际的用户消费位置信息，这些信息也以顺序方式刷新到磁盘</li></ol><h2 id="4-为什么kafka设计中要引入分区，好处是什么？"><a href="#4-为什么kafka设计中要引入分区，好处是什么？" class="headerlink" title="4. 为什么kafka设计中要引入分区，好处是什么？"></a>4. 为什么<code>kafka</code>设计中要引入分区，好处是什么？</h2><p>如果没有引入分区，意味着只能写入一台机器，不利于数据负载均衡和横向扩展。</p><p>引入多分区对写，<strong>分区落在不同服务器，提升并发写的能力</strong></p><p>读方面，<strong>消费消息的时候是跟消费者组进行绑定，可以从不同节点的不同分区进行消费消息，提高了读消息的能力</strong></p><h2 id="5-消息丢失"><a href="#5-消息丢失" class="headerlink" title="5. 消息丢失"></a>5. 消息丢失</h2><h3 id="5-1-生产者丢失"><a href="#5-1-生产者丢失" class="headerlink" title="5.1 生产者丢失"></a>5.1 生产者丢失</h3><ul><li>异步发送，无回调 ： 解决 异步回调，重试机制</li></ul><h3 id="5-2-broker-丢失"><a href="#5-2-broker-丢失" class="headerlink" title="5.2 broker 丢失"></a>5.2 broker 丢失</h3><h4 id="5-2-1-丢失场景"><a href="#5-2-1-丢失场景" class="headerlink" title="5.2.1 丢失场景"></a>5.2.1 丢失场景</h4><ul><li><p>消息异步刷盘</p></li><li><p>单副本</p></li></ul><h3 id="5-2-2-kafak-和rocketMq防丢失配置"><a href="#5-2-2-kafak-和rocketMq防丢失配置" class="headerlink" title="5.2.2 kafak 和rocketMq防丢失配置"></a>5.2.2 kafak 和rocketMq防丢失配置</h3><ul><li><p>RocketMQ分为同步刷盘和异步刷盘（异步刷前宕机丢失）</p></li><li><p>kafak消息中间件配置：</p></li></ul><ol><li><p>acks&#x3D;all 只有参与复制的所有节点全部收到消息，才返回⽣产者成功。这样的话除⾮所有的节点都挂了，消息才会丢失。</p></li><li><p>replication.factor&#x3D;N,设置⼤于1的数，这会要求每个partion⾄少有2个副本</p></li><li><p>min.insync.replicas&#x3D;N，设置⼤于1的数，这会要求leader⾄少感知到⼀个follower还保持着连接</p></li><li><p>retries&#x3D;N，设置⼀个⾮常⼤的值，让⽣产者发送失败⼀直重试</p></li></ol><h3 id="5-3-消费者丢失"><a href="#5-3-消费者丢失" class="headerlink" title="5.3 消费者丢失"></a>5.3 消费者丢失</h3><ul><li><code>ack</code>自动提交，服务挂了，导致丢失，解决方案：改为手动提交</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络相关</title>
      <link href="/2022/08/15/%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/08/15/%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="4次挥手"><a href="#4次挥手" class="headerlink" title="4次挥手"></a>4次挥手</h2><p><img src="/../images/%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="image-20230206173424189"></p><p>4次回收目的： <strong>为了确保数据能够完成传输。</strong></p><ul><li><p>客户端突然挂掉了怎么办？</p><p>务器端设置保活计时器，每当服务器收到客户端的消息，就将计时器复位。超时时间通常设置为2小时。</p></li></ul><p>若服务器超过2小时没收到客户的信息，他就发送探测报文段。若发送了10个探测报文段，每一个相隔75秒，还没有响应就认为客户端出了故障，因而终止该连接</p><p><strong>第一个问题：服务端大量处于 TIME_WAIT 状态连接的原因。</strong></p><p>在 Linux 上 2MSL 的时长是 60 秒，也就是说<strong>停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p><p>为什么需要 TIME_WAIT 状态？</p><p><strong>保证「被动关闭连接」的一方，能被正确的关闭</strong></p><p>什么场景下服务端会主动断开连接呢?</p><ul><li><p>第一个场景：HTTP 没有使用长连接</p><p>Connection: Keep-Alive</p></li><li><p>第二个场景：HTTP 长连接超时</p></li><li><p>第三个场景：HTTP 长连接的请求数量达到上限</p></li></ul><p><strong>第二个问题：服务端大量处于 CLOSE_WAIT 状态连接的原因。</strong></p><p>  查看代码是否有调用close 方法</p><h2 id="2-http1-0-http1-1-和-http2-0"><a href="#2-http1-0-http1-1-和-http2-0" class="headerlink" title="2. http1.0  , http1.1 和 http2.0"></a>2. http1.0  , http1.1 和 http2.0</h2><p>1.新的二进制格式传输：二进制即0和1的组合，实现方便健壮，而1.x版本是基于文本，解析存在缺陷</p><p>2.多路复用：一个连接可以有多个请求，且可以混杂在一起根据requestid来区分不同的请求，提高了连接的利用率，降低了延迟</p><p>3.header头部压缩：通讯两方各自缓存了一份 header请求头表，避免了重复的header传输，且缩小了包的体积大小</p><p>4.服务端推送功能：可以服务端主动向客户端push消息</p><h2 id="3-什么是跨域问题？如何解决？"><a href="#3-什么是跨域问题？如何解决？" class="headerlink" title="3. 什么是跨域问题？如何解决？"></a>3. 什么是跨域问题？如何解决？</h2><p><strong>跨域问题本质是浏览器的一种保护机制，它的初衷是为了保证用户的安全，防止恶意网站窃取数据</strong></p><p><strong>在返回头中设置“Access-Control-Allow-Origin”参数即可解决跨域问题，此参数就是用来表示允许跨域访问的原始域名的，当设置为“*”时，表示允许所有站点跨域访问</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">   public CorsFilter corsFilter() &#123;</span><br><span class="line">       // 1.创建 CORS 配置对象</span><br><span class="line">       CorsConfiguration config = new CorsConfiguration();</span><br><span class="line">       // 支持域</span><br><span class="line">       config.addAllowedOriginPattern(&quot;*&quot;);</span><br><span class="line">       // 是否发送 Cookie</span><br><span class="line">       config.setAllowCredentials(true);</span><br><span class="line">       // 支持请求方式</span><br><span class="line">       config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">       // 允许的原始请求头部信息</span><br><span class="line">       config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">       // 暴露的头部信息</span><br><span class="line">       config.addExposedHeader(&quot;*&quot;);</span><br><span class="line">       // 2.添加地址映射</span><br><span class="line">       UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource();</span><br><span class="line">       corsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;, config);</span><br><span class="line">       // 3.返回 CorsFilter 对象</span><br><span class="line">       return new CorsFilter(corsConfigurationSource);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生产OOM问题处理</title>
      <link href="/2022/08/15/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2022/08/15/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-orika框架引发的元空间OOM问题"><a href="#1-orika框架引发的元空间OOM问题" class="headerlink" title="1. orika框架引发的元空间OOM问题"></a>1. orika框架引发的元空间OOM问题</h2><h3 id="1-1-现象"><a href="#1-1-现象" class="headerlink" title="1.1 现象"></a>1.1 现象</h3><p>   应用启动后元空间持续缓慢增长，一直到达256M引发java.lang.OutOfMemoryError: Metaspace</p><h3 id="1-2-解决"><a href="#1-2-解决" class="headerlink" title="1.2 解决"></a>1.2 解决</h3><p>defaultMap每次调用都会创建MapperFactory工厂，应orika内部使用了反射会导致创建大量的反射类。</p><p>错误方式： </p><p><img src="/../images/%E6%9D%82%E9%A1%B9/image-20230202135223359.png" alt="image-20230202135223359"></p><p>正确把  new DefaultMapperFactor.Builder().bulid()；提取出来</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生产问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>限流</title>
      <link href="/2022/08/15/%E9%99%90%E6%B5%81/"/>
      <url>/2022/08/15/%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-漏桶"><a href="#1-漏桶" class="headerlink" title="1. 漏桶"></a>1. 漏桶</h2><h2 id="2-令牌桶"><a href="#2-令牌桶" class="headerlink" title="2. 令牌桶"></a>2. 令牌桶</h2><p>​     令牌桶算法是指系统以一定地速度往令牌桶里丢令牌，当一个请求过来的时候，会去令牌桶里申请一个令牌，如果能够获取到令牌，那么请求就可以正常进行，反之被丢弃。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring事务配置</title>
      <link href="/2022/08/15/%E4%BB%A3%E7%A0%81/spring%E4%B8%ADMongo%E5%92%8Cmybatis%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/08/15/%E4%BB%A3%E7%A0%81/spring%E4%B8%ADMongo%E5%92%8Cmybatis%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="配置事务"><a href="#配置事务" class="headerlink" title="配置事务"></a>配置事务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TranscationConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name = &quot;mongoTransactionManager&quot;)</span></span><br><span class="line">    MongoTransactionManager <span class="title function_">transactionManager</span><span class="params">(MongoDbFactory factory)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MongoTransactionManager</span>(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean(name = &quot;javaTransactionManager&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span> <span class="comment">//事务默认使用mysql数据库</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">testTransactionManager</span><span class="params">(<span class="meta">@Qualifier(&quot;dataSource&quot;)</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">同时支持</span><br><span class="line">@Configuration</span><br><span class="line">public class TransactionConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    MongoTransactionManager mongoTransactionManager(MongoDbFactory mongoDbFactory) &#123;</span><br><span class="line">        return new MongoTransactionManager(mongoDbFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    DataSourceTransactionManager transactionManager(DataSource dataSource) &#123;</span><br><span class="line">        return new DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    public PlatformTransactionManager chainedTransactionManager(MongoTransactionManager mongoTransactionManager,</span><br><span class="line">                                                                DataSourceTransactionManager dataSourceTransactionManager) &#123;</span><br><span class="line">        return new ChainedTransactionManager(mongoTransactionManager, dataSourceTransactionManager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring扩展点</title>
      <link href="/2022/08/15/%E4%BB%A3%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9/"/>
      <url>/2022/08/15/%E4%BB%A3%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-nacos-服务注册，扩展数据存储"><a href="#1-nacos-服务注册，扩展数据存储" class="headerlink" title="1. nacos 服务注册，扩展数据存储"></a>1. nacos 服务注册，扩展数据存储</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(</span><br><span class="line">    value = &quot;execution(* org.springframework.cloud.client.serviceregistry.ServiceRegistry+.register(..)) &amp;&amp; args(registration)&quot;,</span><br><span class="line">    argNames = &quot;registration&quot;</span><br><span class="line">)</span><br><span class="line">private void pointcut(Registration registration) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Before(</span><br><span class="line">    value = &quot;pointcut(registration)&quot;,</span><br><span class="line">    argNames = &quot;registration&quot;</span><br><span class="line">)</span><br><span class="line">private void beforeServiceRegister(Registration registration) &#123;</span><br><span class="line">    if (CollectionUtils.isNotEmpty(this.processors) &amp;&amp; registration != null) &#123;</span><br><span class="line">        this.processors.forEach((each) -&gt; &#123;</span><br><span class="line">            each.processing(@Pointcut(</span><br><span class="line">        value = &quot;execution(* org.springframework.cloud.client.serviceregistry.ServiceRegistry+.register(..)) &amp;&amp; args(registration)&quot;,</span><br><span class="line">        argNames = &quot;registration&quot;</span><br><span class="line">    )</span><br><span class="line">    private void pointcut(Registration registration) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(</span><br><span class="line">        value = &quot;pointcut(registration)&quot;,</span><br><span class="line">        argNames = &quot;registration&quot;</span><br><span class="line">    )</span><br><span class="line">    private void beforeServiceRegister(Registration registration) &#123;</span><br><span class="line">        Map&lt;String, String&gt; metaData= getMetadata();</span><br><span class="line">        mataData.put(&quot;1&quot;,&quot;2&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工作中常用代码</title>
      <link href="/2022/08/15/%E4%BB%A3%E7%A0%81/%E4%BB%A3%E7%A0%81/"/>
      <url>/2022/08/15/%E4%BB%A3%E7%A0%81/%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程池统一异常打印"><a href="#1-线程池统一异常打印" class="headerlink" title="1.线程池统一异常打印"></a>1.线程池统一异常打印</h2><p>但是当线程池调用方法很多时，那么每个线程执行方法内都要 <code>try/catch</code> 处理，这就不优雅了，其实<code>ThreadPoolExecutor</code>类还支持传入 <code>ThreadFactory</code> 参数，自定义线程工厂，在创建 <code>thread</code> 时，指定 <code>setUncaughtExceptionHandler</code> 异常处理方法，这样就可以做到全局处理异常了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory threadFactory = r -&gt; &#123;</span><br><span class="line">    Thread thread = new Thread(r);</span><br><span class="line">    thread.setUncaughtExceptionHandler((t, e) -&gt; &#123;</span><br><span class="line">        // 记录线程异常</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125;);</span><br><span class="line">    return thread;</span><br><span class="line">&#125;;</span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 60,</span><br><span class="line">        TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(100000),</span><br><span class="line">        threadFactory);</span><br><span class="line">threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">    log.info(&quot;---------------------&quot;);</span><br><span class="line">    int i = 1 / 0;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-优雅得Springboot-mybatis配置多数据源方式"><a href="#2-优雅得Springboot-mybatis配置多数据源方式" class="headerlink" title="2. 优雅得Springboot + mybatis配置多数据源方式"></a>2. 优雅得<code>Springboot + mybatis</code>配置多数据源方式</h2><p><code>Springboot + mybatis</code> 得项目中一般通过 <code>@MapperScan</code> 注解配置 <code>dao</code> 层包目录，来实现 <code>dao</code> 层增强，其实项目中配置一个<code>@MapperScan</code> 是指定一个数据源，配置两个<code>@MapperScan</code>就可以指定两个数据源，通过不同得 <code>dao</code> 层包目录区分，来实现不同数据源得访问隔离。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 主数据源</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages = &#123;&quot;com.xxx.dao.master&quot;&#125;,</span><br><span class="line">        sqlSessionFactoryRef = &quot;MasterSqlSessionFactory&quot;)</span><br><span class="line">public class MasterDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;MasterDataSource&quot;)</span><br><span class="line">    @Qualifier(&quot;MasterDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource.master&quot;)</span><br><span class="line">    public DataSource clickHouseDataSource() &#123;</span><br><span class="line">        return DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;MasterSqlSessionFactory&quot;)</span><br><span class="line">    public SqlSessionFactory getSqlSessionFactory(@Qualifier(&quot;MasterDataSource&quot;) DataSource dataSource) throws Exception &#123;</span><br><span class="line">        MybatisSqlSessionFactoryBean sessionFactoryBean = new MybatisSqlSessionFactoryBean();</span><br><span class="line">        sessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver()</span><br><span class="line">                .getResources(&quot;classpath*:mapper/master/*.xml&quot;));</span><br><span class="line">        log.info(&quot;------------------------------------------MasterDataSource 配置成功&quot;);</span><br><span class="line">        return sessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从数据源</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages = &#123;&quot;com.xxx.dao.slave&quot;&#125;,</span><br><span class="line">        sqlSessionFactoryRef = &quot;SlaveSqlSessionFactory&quot;)</span><br><span class="line">public class SlaveDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;SlaveDataSource&quot;)</span><br><span class="line">    @Qualifier(&quot;SlaveDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource.slave&quot;)</span><br><span class="line">    public DataSource clickHouseDataSource() &#123;</span><br><span class="line">        return DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;SlaveSqlSessionFactory&quot;)</span><br><span class="line">    public SqlSessionFactory getSqlSessionFactory(@Qualifier(&quot;SlaveDataSource&quot;) DataSource dataSource) throws Exception &#123;</span><br><span class="line">        MybatisSqlSessionFactoryBean sessionFactoryBean = new MybatisSqlSessionFactoryBean();</span><br><span class="line">        sessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver()</span><br><span class="line">                .getResources(&quot;classpath*:mapper/slave/*.xml&quot;));</span><br><span class="line">        log.info(&quot;------------------------------------------SlaveDataSource 配置成功&quot;);</span><br><span class="line">        return sessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">数据源yml配置</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driverClassName: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # 主库数据源</span><br><span class="line">    master:</span><br><span class="line">      url: jdbc:mysql://localhost:3306/db1?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8</span><br><span class="line">      username: root</span><br><span class="line">      password:</span><br><span class="line">    slave:</span><br><span class="line">      url: jdbc:mysql://localhost:3306/db2?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8</span><br><span class="line">      username: root</span><br><span class="line">      password:</span><br></pre></td></tr></table></figure><h2 id="3-MDC-在父子线程使用"><a href="#3-MDC-在父子线程使用" class="headerlink" title="3. MDC 在父子线程使用"></a>3. <code>MDC</code> 在父子线程使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义Spring线程池，解决子线程丢失reqest_id问题</span><br><span class="line"> */</span><br><span class="line">public class ThreadPoolExecutorMdcWrapper extends ThreadPoolTaskExecutor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(Runnable task) &#123;</span><br><span class="line">        super.execute(ThreadMdcUtil.wrap(task, MDC.getCopyOfContextMap()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">        return super.submit(ThreadMdcUtil.wrap(task, MDC.getCopyOfContextMap()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        return super.submit(ThreadMdcUtil.wrap(task, MDC.getCopyOfContextMap()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * MDC帮助类，添加reqest_id</span><br><span class="line"> */</span><br><span class="line">public class ThreadMdcUtil &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static final String REQUEST_ID = &quot;request_id&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置请求唯一ID</span><br><span class="line">     */</span><br><span class="line">    public static void setTraceIdIfAbsent() &#123;</span><br><span class="line">        if (MDC.get(REQUEST_ID) == null) &#123;</span><br><span class="line">            MDC.put(REQUEST_ID, IdUtil.getUid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 存在userId则添加到REQUEST_ID中</span><br><span class="line">     * @param userId</span><br><span class="line">     */</span><br><span class="line">    public static void setUserId(String userId) &#123;</span><br><span class="line">        String s = MDC.get(REQUEST_ID);</span><br><span class="line">        if (s != null) &#123;</span><br><span class="line">            MDC.put(REQUEST_ID, s + &quot;_&quot; + userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void removeTraceId() &#123;</span><br><span class="line">        MDC.remove(REQUEST_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; Callable&lt;T&gt; wrap(final Callable&lt;T&gt; callable, final Map&lt;String, String&gt; context) &#123;</span><br><span class="line">        return () -&gt; &#123;</span><br><span class="line">            if (context == null) &#123;</span><br><span class="line">                MDC.clear();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                MDC.setContextMap(context);</span><br><span class="line">            &#125;</span><br><span class="line">            setTraceIdIfAbsent();</span><br><span class="line">            try &#123;</span><br><span class="line">                return callable.call();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                MDC.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Runnable wrap(final Runnable runnable, final Map&lt;String, String&gt; context) &#123;</span><br><span class="line">        return () -&gt; &#123;</span><br><span class="line">            if (context == null) &#123;</span><br><span class="line">                MDC.clear();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                MDC.setContextMap(context);</span><br><span class="line">            &#125;</span><br><span class="line">            // 设置traceId</span><br><span class="line">            setTraceIdIfAbsent();</span><br><span class="line">            try &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                MDC.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;。</span><br></pre></td></tr></table></figure><p>在 最后在 <code>logback.xml</code> 中添加 <code>%X&#123;request_id&#125;</code></p><h2 id="4-下载设置"><a href="#4-下载设置" class="headerlink" title="4.下载设置"></a>4.下载设置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(&quot;application/vnd.ms-excel&quot;);</span><br><span class="line">response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span><br><span class="line">String fileName = URLEncoder.encode(&quot;认证流水&quot;, &quot;UTF-8&quot;);</span><br><span class="line">response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot; + fileName + &quot;.xlsx&quot;);</span><br><span class="line">EasyExcel.write(response.getOutputStream(), ChinaPayRecordDto.class).sheet(&quot;认证流水&quot;).doWrite(list);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC设计</title>
      <link href="/2022/08/15/%E6%96%B9%E6%A1%88/RPC/"/>
      <url>/2022/08/15/%E6%96%B9%E6%A1%88/RPC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-RPC-基础结构"><a href="#1-RPC-基础结构" class="headerlink" title="1.RPC 基础结构"></a>1.<code>RPC</code> 基础结构</h2><ol><li>Client</li><li>Client-stub</li><li><code>RPCRuntime</code></li><li>Server-stub</li><li>Server</li></ol><h2 id="2-RPC重要组成"><a href="#2-RPC重要组成" class="headerlink" title="2. RPC重要组成"></a>2. <code>RPC</code>重要组成</h2><h3 id="2-1-序列化"><a href="#2-1-序列化" class="headerlink" title="2.1 序列化"></a>2.1 序列化</h3><h3 id="2-2-网络传输"><a href="#2-2-网络传输" class="headerlink" title="2.2  网络传输"></a>2.2  网络传输</h3><h2 id="2-3-调用方式"><a href="#2-3-调用方式" class="headerlink" title="2.3 调用方式"></a>2.3 调用方式</h2><ul><li>同步</li><li>异步</li></ul><h3 id="2-4-服务治理"><a href="#2-4-服务治理" class="headerlink" title="2.4 服务治理"></a>2.4 服务治理</h3><ul><li>负载均衡</li><li>服务注册和发现</li><li>高可用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟队列实现</title>
      <link href="/2022/08/15/%E4%BB%A3%E7%A0%81/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E4%BB%A3%E7%A0%81/"/>
      <url>/2022/08/15/%E4%BB%A3%E7%A0%81/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-redission-延迟消息"><a href="#1-redission-延迟消息" class="headerlink" title="1.redission 延迟消息"></a>1.redission 延迟消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 放消息</span></span><br><span class="line">  RQueue&lt;TipMessageDTO&gt; queue = redissonClient.getQueue(<span class="string">&quot;延迟消息队列常量&quot;</span>);</span><br><span class="line">  RDelayedQueue&lt;TipMessageDTO&gt; delayedQueue =redissonClient.getDelayedQueue(queue);</span><br><span class="line">  delayedQueue.offer(tipMessageDTO, delayMill, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消息</span></span><br><span class="line">RBlockingQueue&lt;Object&gt; blockingFairQueue =redissonClient.getBlockingQueue(HEART_LOOP_OPT_DELAYED_QUEUE);</span><br><span class="line"> <span class="comment">// 应用启动时往队列里面放一个空值【如果不放数据,重启应用可能导致队列已有的数据消费不及时】</span></span><br><span class="line"> RDelayedQueue&lt;Object&gt; delayedQueue = redissonClient.getDelayedQueue(blockingFairQueue);</span><br><span class="line">        delayedQueue.offer(<span class="literal">null</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> blockingFairQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (Objects.nonNull(obj)) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;事件重试:&#123;&#125;&quot;</span>, obj);</span><br><span class="line">                    eventPublisher.publishEvent(obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;处理延迟队列失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式id生成方案</title>
      <link href="/2022/08/15/%E6%96%B9%E6%A1%88/%E5%88%86%E5%B8%83%E5%BC%8Fid/"/>
      <url>/2022/08/15/%E6%96%B9%E6%A1%88/%E5%88%86%E5%B8%83%E5%BC%8Fid/</url>
      
        <content type="html"><![CDATA[<h2 id="1-segment-号段模式"><a href="#1-segment-号段模式" class="headerlink" title="1. segment 号段模式"></a>1. segment 号段模式</h2><h3 id="1-1-普通号段"><a href="#1-1-普通号段" class="headerlink" title="1.1 普通号段"></a>1.1 普通号段</h3><h3 id="1-2-双buffer优化优化"><a href="#1-2-双buffer优化优化" class="headerlink" title="1.2 双buffer优化优化"></a>1.2 双buffer优化优化</h3><h2 id="2-雪花算法-或者改进"><a href="#2-雪花算法-或者改进" class="headerlink" title="2. 雪花算法 或者改进"></a>2. 雪花算法 或者改进</h2><blockquote><p>雪花算法 一位固定位+41时间戳+10机器码+12序列号</p></blockquote><p>雪花算法缺点:  </p><p> 时钟回拨</p><ul><li>记录最近一次生成时间进行比较，如果小于5ms等待两倍时间重试</li><li>跨度过大直接抛异常人工处理</li></ul><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><p>美团Leaf:<a href="https://link.segmentfault.com/?enc=BEACBcDCiPevqhu4l6xVIQ==.FHi+7COWEi3O1FF2XT+IRm/73DJddeKG1kn2MjRcQbk/wu92RIni+Io7dyKZ3gApACni+rqZxRC8n9Rn0La4UNuS7kMeA1bgEzFhDPDhaWA=">https://tech.meituan.com/2019...</a></p><ul><li><p>leaf-segment 方案</p><ul><li>优化：双buffer + 预分配</li><li>容灾：Mysql DB 一主两从，异地机房，半同步方式</li><li>缺点：如果用segment号段式方案：id是递增，可计算的，不适用于订单ID生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的。</li></ul></li><li><p>leaf-snowflake方案</p><ul><li>使用Zookeeper持久顺序节点的特性自动对snowflake节点配置workerID<ul><li>1.启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</li><li>2.如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</li><li>3.如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</li></ul></li><li>缓存workerID，减少第三方组件的依赖</li><li>由于强依赖时钟，对时间的要求比较敏感，在机器工作时NTP同步也会造成秒级别的回退，建议可以直接关闭NTP同步。要么在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可。<strong>或者做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警</strong></li></ul></li><li><p>百度UIDGenerator: </p><ul><li>UidGenerator是Java实现的, 基于<a href="https://link.segmentfault.com/?enc=ruZWccU4MR990ISOTA2iiw==.m71vIf1TnpOBUeDPPcSGG65p3507rpHixV/zV+w8mpyIM75wZnqkdLgo0oPPYzMy">Snowflake</a>算法的唯一ID生成器。UidGenerator以组件形式工作在应用项目中, 支持自定义workerId位数和初始化策略, 从而适用于<a href="https://link.segmentfault.com/?enc=F8AqVgaignPPxsFYbNQRyw==.Oxtofrn3KTuVPOxI1/A5e+wE6jrUVaC/mfQ5bnPwwsE=">docker</a>等虚拟化环境下实例自动重启、漂移等场景。 在实现上, UidGenerator通过借用未来时间来解决sequence天然存在的并发限制; 采用RingBuffer来缓存已生成的UID, 并行化UID的生产和消费, 同时对CacheLine补齐，避免了由RingBuffer带来的硬件级「伪共享」问题. 最终单机QPS可达600万。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟消息队列</title>
      <link href="/2022/08/15/%E6%96%B9%E6%A1%88/%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/"/>
      <url>/2022/08/15/%E6%96%B9%E6%A1%88/%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JDK自带的延时队列"><a href="#1-JDK自带的延时队列" class="headerlink" title="1. JDK自带的延时队列"></a>1. JDK自带的延时队列</h2><blockquote><p>JDK中提供了一种延迟队列数据结构DelayQueue，其本质是封装了PriorityQueue，可以把元素进行排序。</p></blockquote><img src="\images\图片\jdk延迟队列.png" alt="jdk延迟队列" style="zoom: 67%;" /><ol><li>把订单插入DelayQueue中，以超时时间作为排序条件，将订单按照超时时间从小到大排序。</li><li>起一个线程不停轮询队列的头部，如果订单的超时时间到了，就出队进行超时处理，并更新订单状态到数据库中。</li><li>为了防止机器重启导致内存中的DelayQueue数据丢失，每次机器启动的时候，需要从数据库中初始化未结束的订单，加入到DelayQueue中。</li></ol><ul><li><p>优点：简单，不需要借助其他第三方组件，成本低。</p></li><li><p>缺点：</p></li><li><ul><li>所有超时处理订单都要加入到DelayQueue中，占用内存大。</li><li>没法做到分布式处理，只能在集群中选一台leader专门处理，效率低。</li><li>不适合订单量比较大的场景。</li></ul></li></ul><h2 id="2-RabbitMQ的延时消息"><a href="#2-RabbitMQ的延时消息" class="headerlink" title="2.RabbitMQ的延时消息"></a>2.RabbitMQ的延时消息</h2><p>RabbitMQ的延时消息主要有两个解决方案：</p><ul><li>RabbitMQ Delayed Message Plugin</li></ul><p>​       RabbitMQ Delayed Message Plugin是官方提供的延时消息插件，虽然使用起来比较方便，但是不是高可用的，如果节点挂了会导致消息丢失</p><ul><li><p>消息的TTL+死信Exchange</p></li><li><p>TTL：即消息的存活时间。RabbitMQ可以对队列和消息分别设置TTL，如果对队列设置，则队列中所有的消息都具有相同的过期时间。超过了这个时间，我们认为这个消息就死了，称之为死信。</p></li><li><p>死信Exchange（DLX）：一个消息在满足以下条件会进入死信交换机</p></li><li><ul><li>一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。</li><li>TTL到期的消息。</li><li>队列满了被丢弃的消息。</li></ul></li><li><img src="..\图片\rabbitMq延时队列实现.png" alt="rabbitMq延时队列实现" style="zoom: 67%;" /></li></ul><p>​         </p><ol><li>定义一个BizQueue，用来接收死信消息，并进行业务消费。</li><li>定义一个死信交换机(DLXExchange)，绑定BizQueue，接收延时队列的消息，并转发给BizQueue。</li><li>定义一组延时队列DelayQueue_xx，分别配置不同的TTL，用来处理固定延时5s、10s、30s等延时等级，并绑定到DLXExchange。</li><li>定义DelayExchange，用来接收业务发过来的延时消息，并根据延时时间转发到不同的延时队列中。</li></ol><ul><li><p>优点：可以支持海量延时消息，支持分布式处理。</p></li><li><p>缺点：</p></li><li><ul><li>不灵活，只能支持固定延时等级。</li><li>使用复杂，要配置一堆延时队列。</li></ul></li></ul><p>引入文章： <a href="https://mp.weixin.qq.com/s/OmbyxkufVm-XzwIv_A514w">https://mp.weixin.qq.com/s/OmbyxkufVm-XzwIv_A514w</a></p><h2 id="3-redis-延迟方案"><a href="#3-redis-延迟方案" class="headerlink" title="3. redis 延迟方案"></a>3. redis 延迟方案</h2><h3 id="3-1-redis-key-过期监听"><a href="#3-1-redis-key-过期监听" class="headerlink" title="3.1 redis  key 过期监听"></a>3.1 redis  key 过期监听</h3><p>​    定期删除（随机选取），惰性删除， 无法保证实时性。</p><p>​    Redis过期通知也是不可靠的，Redis在过期通知的时候，如果应用正好重启了，那么就有可能通知事件就丢了。要有其他方案兜底。</p><h3 id="3-2-redis-zset-方案"><a href="#3-2-redis-zset-方案" class="headerlink" title="3.2 redis zset 方案"></a>3.2 redis zset 方案</h3><h2 id="4-RocketMQ-方案"><a href="#4-RocketMQ-方案" class="headerlink" title="4 RocketMQ 方案"></a>4 RocketMQ 方案</h2><p>实现原理： 支持18个等级延迟队列，创建18个延迟对应内部topic，为每一个延迟队列开启延迟任务，到期写入真正的topic队列中</p><p><img src="/../../images/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/RocketMq%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E5%8E%9F%E7%90%86.png" alt="RocketMq延迟消息原理"></p><h2 id="5-定时任务分布式批处理"><a href="#5-定时任务分布式批处理" class="headerlink" title="5. 定时任务分布式批处理"></a>5. 定时任务分布式批处理</h2><p>  定时任务分布式批处理解决方案，即通过定时任务不停轮询数据库的订单，将已经超时的订单捞出来，分发给不同的机器分布式处理：</p><p><img src="/../../images/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%84%E7%90%86.png" alt="RocketMq延迟消息原理"></p><p>使用定时任务分布式批处理的方案具有如下优势：</p><ul><li><strong>稳定性强：</strong>基于通知的方案（比如MQ和Redis），比较担心在各种极端情况下导致通知的事件丢了。使用定时任务跑批，只需要保证业务幂等即可，如果这个批次有些订单没有捞出来，或者处理订单的时候应用重启了，下一个批次还是可以捞出来处理，稳定性非常高。</li><li><strong>效率高：</strong>基于MQ的方案，需要一个订单一个定时消息，consumer处理定时消息的时候也需要一个订单一个订单更新，对数据库tps很高。使用定时任务跑批方案，一次捞出一批订单，处理完了，可以批量更新订单状态，减少数据库的tps。在海量订单处理场景下，批量处理效率最高。</li><li><strong>可运维：</strong>基于数据库存储，可以很方便的对订单进行修改、暂停、取消等操作，所见即所得。如果业务跑失败了，还可以直接通过sql修改数据库来进行批量运维。</li><li><strong>成本低：</strong>相对于其他解决方案要借助第三方存储组件，复用数据库的成本大大降低。</li></ul><p>但是使用定时任务有个天然的缺点：没法做到精度很高。定时任务的延迟时间，由定时任务的调度周期决定。如果把频率设置很小，就会导致数据库的qps比较高，容易造成数据库压力过大，从而影响线上的正常业务。</p><p>所以一般需要抽离出超时中心和超时库来单独做订单的超时调度，在阿里内部，几乎所有的业务都使用<strong>基于定时任务分布式批处理的超时中心来做订单超时处理</strong>，SLA可以做到30秒以内：</p><p><img src="/..%5C%E5%9B%BE%E7%89%87%5C%E9%98%BF%E9%87%8C%E8%B7%91%E6%89%B9%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88.png" alt="阿里跑批定时任务方案"></p>]]></content>
      
      
      <categories>
          
          <category> 方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀设计</title>
      <link href="/2022/08/15/%E6%96%B9%E6%A1%88/%E7%A7%92%E6%9D%80/"/>
      <url>/2022/08/15/%E6%96%B9%E6%A1%88/%E7%A7%92%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1.架构"></a>1.架构</h2><ul><li>接入层，负载均衡： ngnix ：并发度10W+</li><li>应用层 tomcat  ： 并发度800</li><li>持久层 redis ：5万， mysql  1000</li></ul><h2 id="2-方案"><a href="#2-方案" class="headerlink" title="2. 方案"></a>2. 方案</h2><ul><li><p>系统扩容</p></li><li><p>读写分离</p></li><li><p>多级缓存</p></li><li><p>异步解耦</p></li><li><p>流量防刷</p></li><li><p>资源控制</p><p><img src="/../../images/%E6%96%B9%E6%A1%88/%E7%A7%92%E6%9D%80-%E7%BD%91%E7%BB%9C.png" alt="秒杀-网络"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分库分表</title>
      <link href="/2022/08/15/%E6%96%B9%E6%A1%88/%E5%88%86%E5%BC%80%E5%88%86%E8%A1%A8/"/>
      <url>/2022/08/15/%E6%96%B9%E6%A1%88/%E5%88%86%E5%BC%80%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-订单分库分表"><a href="#1-订单分库分表" class="headerlink" title="1. 订单分库分表"></a>1. 订单分库分表</h2><h3 id="1-1-C端查询"><a href="#1-1-C端查询" class="headerlink" title="1.1 C端查询"></a>1.1 C端查询</h3><p>  按订单号包含用户，根据用户作为<code>shardingkey</code>,保证根据订单号和用户都能快速查询</p><h3 id="1-2-B端查询"><a href="#1-2-B端查询" class="headerlink" title="1.2 B端查询"></a>1.2 B端查询</h3><p>​      双写，双写就是下单的数据落两份，C端和B端的各自保存一份，C端用你可以用单号、用户ID做<code>shardingkey</code>都行，B端就用商家卖家的ID作为<code>shardingkey</code>就好了。 </p><p>  或者 通过<strong>离线数仓或者ES</strong>查询，订单数据落库之后，不管你通过<code>binlog</code>还是<code>MQ</code>消息的都形式，把数据同步到数仓或者ES</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2021/08/15/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2021/08/15/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-zookeeper-实现"><a href="#1-zookeeper-实现" class="headerlink" title="1. zookeeper 实现"></a>1. <code>zookeeper</code> 实现</h2><p><code>Zookeeper</code>是通过创建临时顺序节点的方式来实现。</p><p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="zookeeper分布式锁"></p><ol><li>当需要对资源进行加锁时，实际上就是在父节点之下创建一个临时顺序节点。</li><li>客户端A来对资源加锁，首先判断当前创建的节点是否为最小节点，如果是，那么加锁成功，后续加锁线程阻塞等待</li><li>此时，客户端B也来尝试加锁，由于客户端A已经加锁成功，所以客户端B发现自己的节点并不是最小节点，就会去取到上一个节点，并且对上一节点注册监听</li><li>当客户端A操作完成，释放锁的操作就是删除这个节点，这样就可以触发监听事件，客户端B就会得到通知，同样，客户端B判断自己是否为最小节点，如果是，那么则加锁成功。</li></ol><h2 id="2-redis-方案"><a href="#2-redis-方案" class="headerlink" title="2. redis 方案"></a>2. <code>redis</code> 方案</h2><p> <code>redis setNX  EX</code>  :  </p><p>​    <code>NX</code> 代表如果要设置的key已存在，则取消设置</p><p>​    <code>EX</code> 代表过期时间为秒，<code>PX</code>则为毫秒</p><h3 id="2-1-锁超时问题和锁误删"><a href="#2-1-锁超时问题和锁误删" class="headerlink" title="2.1 锁超时问题和锁误删"></a>2.1 <strong>锁超时问题</strong>和锁误删</h3><p>   客户A加锁成功3秒，业务流程执行超过3秒，锁释放，客户B申请锁成功，客户A执行完释放锁，导致释放B申请的锁。</p><p><strong>锁超时</strong>： </p><ul><li>评估业务设置合适的超时时间</li><li>自动续期，通过其他线程为将要过期的线程续期</li></ul><p><strong>锁误删</strong>:</p><ul><li>set 时 生成唯一id，只解锁自己申请的锁，通过<code> lua</code>脚本解锁</li></ul><h3 id="2-2-RedLock算法"><a href="#2-2-RedLock算法" class="headerlink" title="2.2 RedLock算法"></a>2.2 <code>RedLock</code>算法</h3><p>因为在<code>Redis</code>的主从架构下，主从同步是异步的，如果在Master节点加锁成功后，指令还没有同步到Slave节点，此时Master挂掉，Slave被提升为Master，新的Master上并没有锁的数据，其他的客户端仍然可以加锁成功</p><p><code>RedLock</code>的理念下需要至少2个Master节点，多个Master节点之间完全互相独立，彼此之间不存在主从同步和数据复制</p><ol><li>获取当前Unix时间</li><li>按照顺序依次尝试从多个节点锁，如果获取锁的时间小于超时时间，并且超过半数的节点获取成功，那么加锁成功。这样做的目的就是为了避免某些节点已经宕机的情况下，客户端还在一直等待响应结果。举个例子，假设现在有5个节点，过期时间&#x3D;<code>100ms</code>，第一个节点获取锁花费<code>10ms</code>，第二个节点花费<code>20ms</code>，第三个节点花费<code>30ms</code>，那么最后锁的过期时间就是100-(10+20+30)，这样就是加锁成功，反之如果最后时间&lt;0，那么加锁失败</li><li>如果加锁失败，那么要释放所有节点上的锁</li></ol><p><code> RedLock</code> 存在问题</p><ul><li><strong>性能、资源</strong> : 对多个节点加锁，耗时加长</li><li><strong>节点崩溃重启</strong></li></ul><p>​     比如有1~5号五个节点，并且没有开启持久化，客户端A在1，2，3号节点加锁成功，此时3号节点崩溃宕机后发生重启，就丢失了加锁信息，客户端B在3，4，5号节点加锁成功。</p><ol><li><code>Redis</code>作者建议的方式就是延时重启，比如3号节点宕机之后不要立刻重启，而是等待一段时间后再重启，这个时间必须大于锁的有效时间，也就是锁失效后再重启，这种人为干预的措施真正实施起来就比较困难了</li><li>第二个方案那么就是开启持久化，但是这样对性能又造成了影响。比如如果开启<code>AOF</code>默认每秒一次刷盘，那么最多丢失一秒的数据，如果想完全不丢失的话就对性能造成较大的影响。</li></ol><ul><li><strong><code>GC</code>、网络延迟</strong></li></ul><p>​    <code>client1</code>线程获取到锁，然后发生<code>GC</code>停顿，超过了锁的有效时间导致锁被释放，然后锁被<code>client2</code>拿到，然后两个客户端同时拿到锁在写数据，问题产生。</p><ul><li><strong>时钟跳跃</strong></li></ul><p>​      假设发生网络分区，4、5号节点变为一个独立的子网，3号节点发生始终跳跃（不管人为操作还是同步导致）导致锁过期，这时候另外的客户端就可以从3、4、5号节点加锁成功，问题又发生了。</p><h3 id="2-3-终极方案-redission"><a href="#2-3-终极方案-redission" class="headerlink" title="2.3 终极方案 redission"></a>2.3 终极方案 <code>redission</code></h3><p> 支持单机，集群，哨兵</p><h3 id="1-加锁"><a href="#1-加锁" class="headerlink" title="1.加锁"></a>1.加锁</h3><p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/Redission%E5%8A%A0%E9%94%81.png" alt="zookeeper分布式锁"></p><h3 id="2-释放锁"><a href="#2-释放锁" class="headerlink" title="2. 释放锁"></a>2. 释放锁</h3><p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/Redisson%E9%87%8A%E6%94%BE%E9%94%81.png" alt="zookeeper分布式锁"></p><ol><li>如果key都不存在了，那么就直接返回</li><li>如果key、field不匹配，那么说明不是自己的锁，不能释放，返回空</li><li>释放锁，重入次数-1，如果还大于0那么久刷新过期时间，反之那么久删除锁</li></ol><h3 id="3-watchdog"><a href="#3-watchdog" class="headerlink" title="3. watchdog"></a>3. <strong>watchdog</strong></h3><p>​     解决了锁超时导致的问题，实际上就是一个后台线程，默认每隔10秒自动延长锁的过期时间。</p><p>默认的时间就是<code>internalLockLeaseTime / 3</code>，<code>internalLockLeaseTime</code>默认为30秒。只有不指定锁定时间时生效。</p><h2 id="3-基于关系型数据库"><a href="#3-基于关系型数据库" class="headerlink" title="3. 基于关系型数据库"></a>3. 基于关系型数据库</h2><h3 id="3-1-悲观锁"><a href="#3-1-悲观锁" class="headerlink" title="3.1 悲观锁"></a>3.1 悲观锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from order where order_id = xxx for update</span><br></pre></td></tr></table></figure><p>注意：基于 <code>MySQL</code> 行锁的方式会出现交叉死锁, 通过超时机制解决死锁问题,高并发会出现排队现象，存在性能缺陷</p><h3 id="3-2-基于乐观锁方案"><a href="#3-2-基于乐观锁方案" class="headerlink" title="3.2 基于乐观锁方案"></a>3.2 基于乐观锁方案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select amount, old_ver from order where order_id = xxx</span><br><span class="line">update order set ver = old_ver + 1, amount = yyy where order_id = xxx and ver = old_ver</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
